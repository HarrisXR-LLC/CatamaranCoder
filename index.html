<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Catamaran Coder™</title>

    <!-- ========== CSS STYLES ========== -->
    <style>
/* Design: White minimalist | Grayscale only (#000, #666, #d1d1d1, #e5e5e5, #ebebeb, #fafafa, #fff) | Subtle borders, 4px radius, 0.15s transitions */
:root {
  --selection-color-default: #0066cc;
  --selection-color-previewed: #cc0000;
  --selection-color-applied: #666666;
}

/* CSS State Colors - Keep in sync with JS stateColors */
/* Default/Loaded/Viewed: Blue, Previewed: Red, Applied: Grey */

/* --- Base Reset --- */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', sans-serif;
  background: #fff;
  color: #000;
  height: 100vh;
  display: flex;
  flex-direction: column;
  font-size: 14px;
  overflow: hidden;
}

/* --- Header --- */
.header {
  background: #fff;
  padding: 24px;
  border-bottom: 1px solid #e5e5e5;
}

.header-row {
  display: flex;
  align-items: flex-start;
  gap: 16px;
  margin-bottom: 16px;
}

.header-row:last-child {
  margin-bottom: 0;
}

.header h1 {
  font-size: 19px;
  font-weight: 500;
  margin: 0;
  line-height: 1;
  font-family: 'Palatino Linotype', 'Palatino', 'Book Antiqua', 'Georgia', serif;
  letter-spacing: 1px;
  background: linear-gradient(135deg, rgba(91, 159, 214, 1) 0%, rgba(123, 111, 198, 0.5) 50%, rgba(107, 95, 184, 1) 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  filter: drop-shadow(1px 1px 0px rgba(0, 0, 0, 0.15));
  animation: hueShift 10s ease-in-out infinite;
}

.header-title {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.header-title {
  position: relative;
}

.title-download-button {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(255, 255, 255, 0.95);
  border: 1px solid #d1d1d1;
  border-radius: 3px;
  padding: 4px 8px;
  cursor: pointer;
  font-size: 11px;
  transition: all 0.1s ease;
  opacity: 0;
  pointer-events: none;
  white-space: nowrap;
  z-index: 10;
}

.header-title:hover .title-download-button {
  opacity: 1;
  pointer-events: auto;
}

.title-download-button:hover {
  background: #f0f0f0;
  border-color: #666;
}

.header-subtitle {
  font-size: 12px;
  font-weight: 400;
  font-family: 'Trebuchet MS', 'Verdana', 'Geneva', 'DejaVu Sans', sans-serif;
  letter-spacing: 0.8px;
  line-height: 1;
  color: #6B5FB8;
  opacity: 0.85;
  text-align: center;
  margin-top: 2px;
}

.tm-symbol {
  font-size: 0.45em;
  font-weight: 400;
  vertical-align: super;
  margin-left: 2px;
}

/* --- Logo --- */
.header-logo {
  height: 44px;
  width: auto;
  margin-right: 0;
  object-fit: contain;
  vertical-align: middle;
  display: block;
  animation: hueShift 10s ease-in-out infinite;
}

/* --- Buttons --- */
button {
  background: #fff;
  color: #000;
  border: 1px solid #d1d1d1;
  padding: 6px 16px;
  cursor: pointer;
  font-family: inherit;
  font-size: 13px;
  border-radius: 4px;
  transition: all 0.15s;
}

button:hover {
  border-color: #000;
  background: #fafafa;
}

button:active {
  background: #e5e5e5;
}

/* --- Inputs --- */
input[type="text"],
input[type="number"],
textarea {
  background: #fff;
  border: 1px solid #d1d1d1;
  color: #000;
  padding: 6px 8px;
  font-family: inherit;
  font-size: 13px;
  border-radius: 4px;
  transition: border-color 0.15s;
}

input:focus,
textarea:focus {
  outline: none;
  border-color: #000;
}

/* Preview header theme for paste textareas */
#replaceInput,
#jsonInput {
  background: #ebebeb;
  color: #000;
  border-color: #d1d1d1;
}

#replaceInput:focus,
#jsonInput:focus {
  border-color: #666;
  background: #e5e5e5;
}

#replaceInput::placeholder,
#jsonInput::placeholder {
  color: #666;
}

input[type="number"] {
  width: 60px;
  text-align: center;
}

textarea.find-input {
  width: 280px;
  resize: vertical;
  min-height: 32px;
  font-family: 'SF Mono', Consolas, 'Liberation Mono', monospace;
  font-size: 12px;
}

input[type="checkbox"] {
  cursor: pointer;
  margin-right: 6px;
}

/* --- Main Layout --- */
.container {
  display: flex;
  flex: 1;
  overflow: hidden;
  background: #fafafa;
  min-height: 0;
  /* Important for Firefox flex children */
}

/* --- Editor Section --- */
.editor-section {
  flex: 1;
  display: flex;
  flex-direction: column;
  background: #fff;
  border-right: 1px solid #e5e5e5;
}

.editor-section.full-width {
  border-right: none;
  flex: 1 1 100%;
}

/* --- Tabs --- */
.editor-tabs {
  display: flex;
  background: #ebebeb;
  border-bottom: 1px solid #e5e5e5;
}

.tab {
  flex: 1;
  padding: 12px;
  cursor: pointer;
  background: transparent;
  border: none;
  border-right: 1px solid #e5e5e5;
  color: #666;
  font-size: 13px;
  font-weight: 500;
  transition: all 0.15s;
}

.tab:last-child {
  border-right: none;
}

.tab.active {
  color: #000;
  background: #fff;
  border-bottom: 2px solid #000;
}

.tab:hover:not(.active) {
  color: #000;
  background: #e5e5e5;
}

/* --- Editor --- */
.editor-container {
  flex: 1;
  position: relative;
  overflow: hidden;
}

.editor {
  position: absolute;
  width: 100%;
  height: 100%;
  padding: 24px;
  font-family: 'SF Mono', Consolas, 'Liberation Mono', monospace;
  font-size: 13px;
  line-height: 1.8;
  background: #fff;
  color: #000;
  border: none;
  outline: none;
  resize: none;
  display: none;
  tab-size: 2;
}

.editor.active {
  display: block;
}

/* Selection colors based on step state */
.editor::selection {
  background-color: var(--selection-color-default);
  color: white;
}

.editor.state-previewed::selection {
  background-color: var(--selection-color-previewed);
  color: white;
}

.editor.state-applied::selection {
  background-color: var(--selection-color-applied);
  color: white;
}

/* Editor glow effects based on state */
.editor.state-previewed {
  box-shadow: 0 0 25px rgba(204, 0, 0, 0.8), inset 0 0 15px rgba(204, 0, 0, 0.4);
}

.editor.state-applied {
  box-shadow: 0 0 25px rgba(102, 102, 102, 0.8), inset 0 0 15px rgba(102, 102, 102, 0.4);
}

/* Make cursor more visible */
.editor {
  caret-color: #ff0000;
}

/* --- Preview --- */
.preview-section {
  flex: 1;
  display: flex;
  flex-direction: column;
  background: #fff;
}

.preview-section.hidden {
  display: none;
}

.preview-header {
  background: #ebebeb;
  padding: 12px 24px;
  border-bottom: 1px solid #e5e5e5;
  font-size: 13px;
  font-weight: 500;
  color: #666;
}

.preview-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.preview-container {
  flex: 1;
  background: #fff;
  position: relative;
}

#preview {
  width: 100%;
  height: 100%;
  border: none;
  background: #fff;
}

/* --- Tooltips --- */
[data-tooltip] {
  position: relative;
}

[data-tooltip]::after {
  content: attr(data-tooltip);
  position: absolute;
  bottom: 100%;
  left: 50%;
  transform: translateX(-50%);
  background: #333;
  color: #fff;
  padding: 4px 8px;
  font-size: 11px;
  border-radius: 3px;
  white-space: nowrap;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.15s;
  margin-bottom: 6px;
  z-index: 1000;
}

[data-tooltip]:hover::after {
  opacity: 0.9;
}

[data-tooltip].tooltip-multiline::after {
  white-space: normal;
  max-width: 200px;
  text-align: center;
}

[data-tooltip-pos="bottom"]::after {
  top: 100%;
  bottom: auto;
  margin-top: 6px;
  margin-bottom: 0;
}

/* --- Notifications --- */
[data-notify] {
  position: relative;
}

[data-notify]::before {
  content: attr(data-notify);
  position: absolute;
  bottom: 100%;
  left: 50%;
  transform: translateX(-50%);
  background: #000;
  color: #fff;
  padding: 6px 12px;
  font-size: 11px;
  border-radius: 4px;
  white-space: nowrap;
  margin-bottom: 8px;
  z-index: 1001;
  opacity: 0;
  animation: notifyFadeInOut 2s ease-in-out;
  pointer-events: none;
}

@keyframes notifyFadeInOut {
  0% {
    opacity: 0;
    transform: translateX(-50%) translateY(10px);
  }

  20% {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }

  80% {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }

  100% {
    opacity: 0;
    transform: translateX(-50%) translateY(-10px);
  }
}

[data-notify-pos="bottom"]::before {
  top: 100%;
  bottom: auto;
  margin-top: 8px;
  margin-bottom: 0;
  animation: notifyFadeInOutBottom 2s ease-in-out;
}

@keyframes notifyFadeInOutBottom {
  0% {
    opacity: 0;
    transform: translateX(-50%) translateY(-10px);
  }

  20% {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }

  80% {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }

  100% {
    opacity: 0;
    transform: translateX(-50%) translateY(10px);
  }
}

/* --- Utility --- */

/* --- Position-based Notification --- */
.position-notify {
  position: absolute;
  background: #000;
  color: #fff;
  padding: 6px 12px;
  font-size: 11px;
  border-radius: 4px;
  white-space: nowrap;
  z-index: 10001;
  opacity: 0;
  pointer-events: none;
  transform: translateX(-50%) translateY(-10px);
  transition: none;
}

.position-notify.show {
  animation: positionNotifyAnimation 2s ease-in-out;
}

@keyframes positionNotifyAnimation {
  0% {
    opacity: 0;
    transform: translateX(-50%) translateY(-10px);
  }

  20% {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }

  80% {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }

  100% {
    opacity: 0;
    transform: translateX(-50%) translateY(10px);
  }
}

.position-notify.bottom {
  transform: translateX(-50%) translateY(-10px);
}

.position-notify.bottom.show {
  animation: positionNotifyAnimationBottom 2s ease-in-out;
}

@keyframes positionNotifyAnimationBottom {
  0% {
    opacity: 0;
    transform: translateX(-50%) translateY(-10px);
  }

  20% {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }

  80% {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }

  100% {
    opacity: 0;
    transform: translateX(-50%) translateY(10px);
  }
}

/* --- Drag & Drop Styles --- */
.drag-hover {
  background: #e8f4ff !important;
  border-color: #0066cc !important;
  box-shadow: 0 0 8px rgba(0, 102, 204, 0.3);
}

.drag-hover::placeholder {
  color: #0066cc !important;
}

/* --- Flavor Text Animation --- */
.flavor-text {
  position: absolute;
  top: 85%;
  left: 50%;
  transform: translate(-50%, -50%) rotate(-5deg) scale(0);
  font-size: 11px;
  font-weight: bold;
  color: #fff;
  text-shadow:
    -1px -1px 0 #000,
    1px -1px 0 #000,
    -1px 1px 0 #000,
    1px 1px 0 #000,
    2px 2px 3px rgba(0, 0, 0, 0.3);
  background: linear-gradient(135deg, rgba(91, 159, 214, 0.4) 0%, rgba(123, 111, 198, 0.4) 50%, rgba(107, 95, 184, 0.4) 100%), rgba(255, 255, 255, 0.4);
  padding: 4px 10px;
  border-radius: 6px;
  white-space: nowrap;
  pointer-events: none;
  z-index: 100;
  animation: flavorPulse 2.7s ease-in-out, hueShift 3s ease-in-out infinite;
  opacity: 0;
}

@keyframes flavorPulse {
  0% {
    transform: translate(-50%, -50%) rotate(-5deg) scale(0);
    opacity: 0;
  }

  15% {
    transform: translate(-50%, -50%) rotate(-5deg) scale(1.2);
    opacity: 1;
  }

  30% {
    transform: translate(-50%, -50%) rotate(-5deg) scale(0.9);
    opacity: 1;
  }

  45% {
    transform: translate(-50%, -50%) rotate(-5deg) scale(1.1);
    opacity: 1;
  }

  60% {
    transform: translate(-50%, -50%) rotate(-5deg) scale(0.95);
    opacity: 1;
  }

  75% {
    transform: translate(-50%, -50%) rotate(-5deg) scale(1.05);
    opacity: 1;
  }

  100% {
    transform: translate(-50%, -50%) rotate(-5deg) scale(0);
    opacity: 0;
  }
}

.header-title {
  position: relative;
}

/* --- Hue Animation --- */
@keyframes hueShift {
  0% {
    filter: hue-rotate(0deg) drop-shadow(1px 1px 0px rgba(0, 0, 0, 0.15));
  }

  25% {
    filter: hue-rotate(18deg) drop-shadow(1px 1px 0px rgba(0, 0, 0, 0.15));
  }

  50% {
    filter: hue-rotate(36deg) drop-shadow(1px 1px 0px rgba(0, 0, 0, 0.15));
  }

  75% {
    filter: hue-rotate(18deg) drop-shadow(1px 1px 0px rgba(0, 0, 0, 0.15));
  }

  100% {
    filter: hue-rotate(0deg) drop-shadow(1px 1px 0px rgba(0, 0, 0, 0.15));
  }
}

.auto-run-container {
  display: flex;
  align-items: center;
  font-size: 13px;
  color: #666;
}

/* --- Full Screen Popup --- */
.fullscreen-popup-backdrop {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.8);
  z-index: 9999;
  display: none;
  opacity: 0;
  transition: opacity 0.3s ease;
}

.fullscreen-popup-backdrop.show {
  display: block;
  opacity: 1;
}

.fullscreen-popup-container {
  position: fixed;
  top: 32px;
  left: 32px;
  right: 32px;
  bottom: 32px;
  background: #fff;
  border-radius: 8px;
  box-shadow: 0 4px 24px rgba(0, 0, 0, 0.3);
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

.fullscreen-popup-header {
  background: #fafafa;
  border-bottom: 1px solid #e5e5e5;
  padding: 24px;
  flex-shrink: 0;
  display: flex;
  align-items: center;
  gap: 24px;
}

.fullscreen-popup-header {
  position: relative;
}

.fullscreen-popup-header h2 {
  margin: 0;
  font-size: 19px;
  font-weight: 500;
}

.fullscreen-popup-close {
  margin-left: auto;
  background: transparent;
  border: none;
  font-size: 24px;
  color: #666;
  cursor: pointer;
  padding: 8px;
  line-height: 1;
  transition: color 0.15s;
}

.fullscreen-popup-close:hover {
  color: #000;
}

.fullscreen-popup-nav {
  display: flex;
  gap: 12px;
  align-items: center;
}

.fullscreen-popup-nav button {
  padding: 6px 16px;
  font-size: 12px;
}

.fullscreen-popup-nav button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.fullscreen-popup-content {
  flex: 1;
  padding: 24px;
  overflow-y: auto;
}

/* Diff highlighting styles */
.diff-line {
  display: block;
  padding: 2px 16px;
  margin: 0 -16px;
  white-space: pre;
}

.diff-line.added {
  background-color: #e6ffed;
  position: relative;
}

.diff-line.removed {
  background-color: #ffebe9;
  position: relative;
}

.diff-line.empty {
  background-color: #f6f8fa;
  color: #959da5;
  min-height: 1.6em;
}

/* Line numbers */
.diff-line-number {
  display: inline-block;
  width: 40px;
  text-align: right;
  color: #959da5;
  margin-right: 16px;
  user-select: none;
}

/* --- Diff Checker Styles --- */
.diff-container {
  display: flex;
  gap: 16px;
  height: 100%;
}

.diff-column {
  flex: 1;
  display: flex;
  flex-direction: column;
  min-width: 0;
  /* Prevent flex children from overflowing */
}

.diff-label {
  font-weight: 500;
  margin-bottom: 8px;
  color: #666;
  font-size: 13px;
  position: sticky;
  top: 0;
  background: #fff;
  padding: 8px 0;
  z-index: 10;
  border-bottom: 1px solid #e5e5e5;
}

.diff-column pre {
  flex: 1;
  margin: 0;
  overflow: hidden;
  /* Hide individual scrollbars */
  margin-top: 0;
  /* Remove any default margin */
}

.diff-column pre code {
  display: block;
  min-height: 100%;
  padding: 16px !important;
}

/* Synchronized scrolling wrapper */
.diff-scroll-container {
  height: 100%;
  overflow-y: auto;
  overflow-x: hidden;
  position: relative;
}

.diff-panels-wrapper {
  display: flex;
  gap: 16px;
  min-height: 100%;
}

/* White background for diff viewer */
.diff-container pre[class*="language-"],
.diff-container code[class*="language-"] {
  background: #fff;
}

/* --- Pulse Effect --- */
@keyframes pulseGlow {
  0% {
    box-shadow: 0 0 0 0 rgba(255, 0, 0, 0);
  }

  50% {
    box-shadow: 0 0 8px 4px var(--pulse-color, rgba(255, 0, 0, 0.6));
  }

  100% {
    box-shadow: 0 0 0 0 rgba(255, 0, 0, 0);
  }
}

.pulse-effect {
  animation: pulseGlow 1s ease-in-out 2;
}

/* --- Caret Tooltip --- */
.caret-tooltip {
  position: absolute;
  background: #000;
  color: #fff;
  padding: 6px 12px;
  font-size: 12px;
  border-radius: 4px;
  white-space: nowrap;
  z-index: 9999;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.2s;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

.caret-tooltip.show {
  opacity: 1;
}

.caret-tooltip::after {
  content: '';
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translateX(-50%);
  border: 5px solid transparent;
  border-top-color: #000;
}

/* Triangle pointing up when tooltip is below caret */
.caret-tooltip.below::after {
  top: auto;
  bottom: 100%;
  border-top-color: transparent;
  border-bottom-color: #000;
}

/* --- Range Indicators --- */
.range-indicator {
  position: absolute;
  background: #000;
  color: #fff;
  padding: 6px 12px;
  font-size: 12px;
  border-radius: 4px;
  white-space: nowrap;
  z-index: 9999;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.2s;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

.range-indicator.show {
  opacity: 1;
}

.range-indicator::after {
  content: '';
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  border: 5px solid transparent;
}

/* Top indicator - arrow points to start of selection */
.top-indicator::after {
  top: 100%;
  border-top-color: inherit;
}

.top-indicator.below::after {
  top: auto;
  bottom: 100%;
  border-top-color: transparent;
  border-bottom-color: inherit;
}

/* Bottom indicator - arrow points to end of selection */
.bottom-indicator::after {
  top: 100%;
  border-top-color: inherit;
}

.bottom-indicator.below::after {
  top: auto;
  bottom: 100%;
  border-top-color: transparent;
  border-bottom-color: inherit;
}

/* --- Range Lines --- */
.range-line {
  position: absolute;
  height: 2px;
  border-top: 2px dotted;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.2s;
  z-index: 9998;
  /* Just below the indicators */
}

.range-line.show {
  opacity: 0.8;
}

/* --- Search Area Design --- */
.search-container {
  display: flex;
  align-items: center;
  gap: 0;
  background: #fff;
  border: 1px solid #d1d1d1;
  border-radius: 4px;
  padding: 2px;
  transition: border-color 0.15s;
}

.search-container:focus-within {
  border-color: #000;
}

.search-textarea-wrapper {
  position: relative;
  flex: 1;
}

.search-textarea {
  border: none;
  background: transparent;
  width: 100%;
  padding: 4px 8px;
  resize: vertical;
  min-height: 28px;
  max-height: 240px;
  font-family: 'SF Mono', Consolas, 'Liberation Mono', monospace;
  font-size: 12px;
  line-height: 1;
}

.search-textarea:focus {
  outline: none;
  border-color: transparent;
}

.search-divider {
  width: 1px;
  background: #e5e5e5;
  align-self: stretch;
  margin: 0 4px;
}

.search-button {
  background: transparent;
  border: none;
  padding: 6px 10px;
  display: flex;
  align-items: center;
  gap: 6px;
  color: #666;
  font-size: 13px;
  cursor: pointer;
  transition: all 0.15s;
  border-radius: 2px;
}

.search-button:hover {
  background: #fafafa;
  color: #000;
}

.search-button:active {
  background: #e5e5e5;
}

.search-dropdown {
  background: transparent;
  border: none;
  padding: 6px 6px;
  color: #666;
  font-size: 10px;
  cursor: pointer;
  transition: all 0.15s;
  border-radius: 2px;
  outline: none;
  min-width: 75px;
  font-family: 'SF Mono', Consolas, 'Liberation Mono', monospace;
}

.search-dropdown:hover {
  background: #fafafa;
  color: #000;
}

.search-dropdown:focus {
  background: #fafafa;
  color: #000;
}

.search-dropdown option {
  background: #fff;
  color: #000;
  padding: 4px;
}

.dropdown-hint {
  color: #999;
  font-size: 11px;
  font-style: italic;
}

.search-icon {
  width: 14px;
  height: 14px;
  stroke: currentColor;
  stroke-width: 2;
  fill: none;
}

.search-accuracy {
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 0 8px;
  color: #666;
  font-size: 12px;
}

.search-accuracy input[type="number"] {
  width: 48px;
  padding: 2px 4px;
  text-align: center;
  border: none;
  background: #fafafa;
  border-radius: 2px;
  font-family: 'SF Mono', Consolas, 'Liberation Mono', monospace;
  font-size: 12px;
}

.search-accuracy input[type="number"]:focus {
  background: #fff;
  outline: 1px solid #d1d1d1;
}

/* --- End Search Area Design --- */

/* --- Textarea Hover Icons --- */
.textarea-with-icons {
  position: relative;
}

.textarea-with-icons[style*="inline-block"] {
  vertical-align: top;
}

.textarea-icons {
  position: absolute;
  top: 4px;
  right: 4px;
  z-index: 100;
}

.textarea-icon {
  background: rgba(255, 255, 255, 0.9);
  border: 1px solid #d1d1d1;
  border-radius: 3px;
  width: 20px;
  height: 20px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  transition: all 0.1s ease;
}

.textarea-icon:hover {
  background: #f0f0f0;
  border-color: #666;
}

/* Vertical layout for downward buttons */
.textarea-icons-vertical {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.textarea-icons-horizontal {
  display: flex;
  flex-direction: row;
  gap: 4px;
}

/* Ensure both button groups display when parent is shown */
.textarea-icons {
  display: none;
  flex-direction: row;
  gap: 4px;
}

.textarea-with-icons:hover .textarea-icons {
  display: flex !important;
}

.textarea-icons-horizontal {
  display: flex;
  flex-direction: row;
  gap: 4px;
}

/* --- Step Info Table --- */
.step-info-table {
  background: #fff;
  border: 1px solid #d1d1d1;
  border-radius: 4px;
  font-size: 11px;
  margin-right: 10px;
  width: 250px;
}

.step-info-table td {
  padding: 4px 8px;
  border-bottom: 1px solid #e5e5e5;
  vertical-align: top;
}

.step-info-table tr:last-child td {
  border-bottom: none;
}

.step-info-table .step-label {
  color: #666;
  font-weight: 500;
  width: 65px;
}

.step-info-table .step-number {
  font-weight: bold;
}

.step-info-table.applied {
  background: #f5f5f5;
}

.step-info-table.applied td {
  color: #666;
}

.step-info-table.applied .step-number {
  color: #666;
}

/* Hide section row by default, show on table hover with smooth animation */
.step-info-table .section-row {
  transition: all 0.3s ease;
}

.step-info-table .section-row td {
  max-height: 0;
  opacity: 0;
  overflow: hidden;
  padding: 0;
  line-height: 0;
  font-size: 0;
  border: 0;
  margin-top: -1px;
  transition: all 0.3s ease;
}

.step-info-table:hover .section-row td {
  max-height: 50px;
  opacity: 1;
  padding: 4px 8px;
  line-height: normal;
  font-size: 11px;
  border-bottom: 1px solid #e5e5e5;
  margin-top: 0;
}

/* Only show section row on hover if table has 'has-section' class */
.step-info-table:not(.has-section) .section-row td {
  max-height: 0 !important;
  opacity: 0 !important;
  padding: 0 !important;
  line-height: 0 !important;
  font-size: 0 !important;
  border: 0 !important;
  margin-top: -1px !important;
}

/* --- Responsive --- */
/* --- Footer Bar --- */
.footer-bar {
  background: #ebebeb;
  border-top: 1px solid #d1d1d1;
  padding: 4px 12px;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 10px;
  color: #666;
  height: 24px;
  flex-shrink: 0;
}

.footer-text {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', sans-serif;
  letter-spacing: 0.3px;
  opacity: 0.8;
  transition: opacity 0.15s;
}

.footer-text:hover {
  opacity: 1;
}

@media (max-width: 768px) {
  .container {
    flex-direction: column;
  }

  .editor-section {
    border-right: none;
    border-bottom: 1px solid #e5e5e5;
    height: 50vh;
  }

  .editor-section.full-width {
    height: 100vh;
    border-bottom: none;
  }

  .preview-section {
    height: 50vh;
  }

  textarea.find-input {
    width: 200px;
  }
}
    </style>
    <!-- ========== END CSS STYLES ========== -->
</head>
<body>
    <!-- ========== HTML CONTENT ========== -->
    <div class="header">
  <!-- ⦿ Section - Primary Header Row (Logo, Title, Copy/Paste, Search) -->
  <div class="header-row">
    <img src="catamarancoderlogo.png" alt="Catamaran Coder Logo" class="header-logo" onerror="this.style.display='none'">
    <div class="header-title">
      <h1>Catamaran Coder<supx class="tm-symbol">™</supx>
      </h1>
      <div class="header-subtitle">— Guided AI Coding —</div>
      <div id="flavorText" class="flavor-text"></div>
      <div class="title-download-button" onclick="app.clipboard.downloadToPC()" title="Download merged HTML to PC">Download to PC</div>
    </div>

    <button id="storeAsBtn" onclick="app.storeAs.show()" data-tooltip="Cache current session" data-tooltip-pos="bottom">Cache</button>

    <button id="copyBtn" onclick="app.clipboard.copy()" data-tooltip="Copy merged HTML" data-tooltip-pos="bottom">Copy</button>
    <button id="openBtn" onclick="app.clipboard.openInNewWindow()" data-tooltip="Open in new window" data-tooltip-pos="bottom">See</button>
    <button id="githubBtn" onclick="app.github.show()" data-tooltip="Upload to GitHub" data-tooltip-pos="bottom">GitHub</button>
    <div class="textarea-with-icons" style="display: inline-block;">
      <textarea id="replaceInput" class="find-input" placeholder="↘ Paste or drop HTML file here..." style="width: 150px;"></textarea>
      <div class="textarea-icons">
      </div>
    </div>

    <div class="search-container" style="margin-left: 10px;" data-tooltip="Ctrl+Alt+F - Find in all tabs" data-tooltip-pos="bottom">
      <div class="search-textarea-wrapper textarea-with-icons">
        <textarea id="findInput" class="search-textarea" placeholder="Find text..." spellcheck="false"></textarea>
      </div>
      <div class="search-divider"></div>
      <select id="findFuzzy" class="search-dropdown" title="Fuzzy matching level">
        <option value="100" selected="">No Fuzzy</option>
        <option value="99">1% Fuzzy</option>
        <option value="97">3% Fuzzy</option>
        <option value="95">5% Fuzzy</option>
        <option value="90">10% Fuzzy</option>
        <option value="85">15% Fuzzy</option>
        <option value="75">25% Fuzzy</option>
        <option value="60">40% Fuzzy</option>
        <option value="50">50% Fuzzy</option>
        <option value="40">60% Fuzzy</option>
        <option value="25">75% Fuzzy 🐌</option>
      </select>
      <div class="search-divider"></div>
      <button class="search-button" onclick="app.search.find()">
        <svg class="search-icon" viewBox="0 0 24 24">
          <circle cx="11" cy="11" r="8"></circle>
          <path d="m21 21-4.35-4.35"></path>
        </svg>
        <span id="findButtonText"></span>
      </button>
    </div>

  </div>

  <!-- ⦿ Section - Editor Utilities Row (Preview Controls, Selection Tools) -->

  <div class="header-row">

    <div class="auto-run-container" style="margin-left: 20px;">
      <input type="checkbox" id="showPreview" checked="">
      <label for="showPreview">Show preview</label>
    </div>
    <div class="auto-run-container" style="margin-left: 20px;">
      <input type="checkbox" id="override5Lines">
      <label for="override5Lines" data-tooltip="Allows you to skip the requirement" data-tooltip-pos="bottom">Override 5 Lines</label>
    </div>

    <button id="findCaretBtn" onclick="app.ui.findCaret()" data-tooltip="Ctrl+Alt+K - Show where the cursor is" data-tooltip-pos="bottom">Find Caret</button>

    <div class="textarea-with-icons" style="margin-left: 10px;">
      <textarea id="topLinesInput" class="find-input" placeholder="Top..." style="width: 120px; min-height: 32px;"></textarea>
      <div class="textarea-icons">
      </div>
    </div>
    <div class="textarea-with-icons">
      <textarea id="bottomLinesInput" class="find-input" placeholder="Bottom..." style="width: 120px; min-height: 32px;"></textarea>
      <div class="textarea-icons">
      </div>
    </div>
    <button id="useSelectionBtn" onclick="app.search.useSelection()" data-tooltip="Use top/bottom to select range" data-tooltip-pos="bottom">Use</button>
    <button id="applyRangeBtn" onclick="app.search.applyRange()" data-tooltip="Apply selection" data-tooltip-pos="bottom">Apply</button>
    <button id="diffCheckBtn" onclick="app.diffCheck.testDiff()" data-tooltip="Click to load diff libraries, then click again to check" data-tooltip-pos="bottom">Diff</button>

    <button id="beautifyBtn" onclick="app.beautify.run()" data-tooltip="Click to load beautify library, then click again to beautify" data-tooltip-pos="bottom">Beautify</button>
  </div>

  <!-- ⦿ Section - JSON Operations Row (JSON Input and Step Controls) -->

  <div class="header-row">
    <div class="textarea-with-icons" style="display: inline-block;">
      <textarea id="jsonInput" class="find-input" placeholder="↘ Paste JSON here to load..." style="width: 150px;"></textarea>
      <div class="textarea-icons">
      </div>
    </div>

    <button id="aiPromptBtn" onclick="app.clipboard.copyAIPrompt()" data-tooltip="Copies AI prompt to clipboard" data-tooltip-pos="bottom">AI Prompt</button>

    <button id="backBtn" onclick="app.jsonOps.back()" data-tooltip="Back one step" data-tooltip-pos="bottom">Back</button>
    <button id="nextBtn" onclick="app.jsonOps.next()" data-tooltip="Forward one step" data-tooltip-pos="bottom">Next</button>
    <button id="applyBtn" onclick="app.jsonOps.getReady()" data-tooltip="Jumps to position and highlights" data-tooltip-pos="bottom">Get Ready</button>
    <button id="applyOperationBtn" onclick="app.jsonOps.confirmAction()" data-tooltip="Applies the operation!" data-tooltip-pos="bottom">Apply Operation</button>
    <button id="jsonWildcardBtn" onclick="app.syntaxCheck.check()" data-tooltip="Check JavaScript syntax" data-tooltip-pos="bottom">{}*</button>
  </div>

  <!-- ⦿ Section - Step Information Row (Step Details and Fields) -->

  <div class="header-row">
    <table class="step-info-table">
      <tbody>
        <tr>
          <td class="step-label">Step:</td>
          <td id="stepNumber" class="step-number">-</td>
        </tr>
        <tr class="section-row">
          <td class="step-label">Section: <span style="cursor: pointer; color: #0066cc;" onclick="app.jsonOps.findSection()" title="Find this section">[↳]</span></td>
          <td id="stepSection">-</td>
        </tr>
        <tr>
          <td class="step-label">Operation:</td>
          <td id="stepOperation">-</td>
        </tr>
        <tr>
          <td class="step-label">Explanation:</td>
          <td id="stepExplanation">-</td>
        </tr>
      </tbody>
    </table>
    <div class="textarea-with-icons">
      <textarea id="stepFind" class="find-input" placeholder="find:" style="width: 200px; min-height: 74px;"></textarea>
      <div class="textarea-icons">
        <div class="textarea-icons-horizontal">
        </div>
        <div class="textarea-icons-vertical">
          <div class="textarea-icon" onclick="app.ui.transferToTopBottom('stepFind', true, this)" title="Send to Top field &amp; select range">⤒</div>
          <div class="textarea-icon" onclick="app.ui.transferToTopBottom('stepFind', false, this)" title="Send to Bottom field &amp; select range">⤓</div>
          <div class="textarea-icon" onclick="app.ui.compareStepFields(this)" title="Diff Check: Find vs Code">Df</div>
        </div>
      </div>
    </div>
    <div class="textarea-with-icons">
      <textarea id="stepCode" class="find-input" placeholder="code:" style="width: 200px; min-height: 74px;"></textarea>
      <div class="textarea-icons">
        <div class="textarea-icons-horizontal">
        </div>
        <div class="textarea-icons-vertical">
          <div class="textarea-icon" onclick="app.ui.compareStepFields(this)" title="Diff Check: Find vs Code">Df</div>
        </div>
      </div>
    </div>
    <div class="textarea-with-icons">
      <textarea id="stepFiveLines" class="find-input" placeholder="five-lines-above:" style="width: 200px; min-height: 74px;"></textarea>
      <div class="textarea-icons">
        <div class="textarea-icons-horizontal">
        </div>
        <div class="textarea-icons-vertical">
          <div class="textarea-icon" onclick="app.ui.transferToTopBottom('stepFiveLines', true, this)" title="Send to Top field &amp; select range">⤒</div>
          <div class="textarea-icon" onclick="app.ui.transferToTopBottom('stepFiveLines', false, this)" title="Send to Bottom field &amp; select range">⤓</div>
        </div>
      </div>
    </div>
  </div>
</div>
<div class="container">

  <!-- ⦿ Section - Overlay Elements (Tooltips and Popups) -->

  <!-- Caret Tooltip -->
  <div id="caretTooltip" class="caret-tooltip"></div>

  <!-- Range Indicators -->
  <div id="topIndicator" class="range-indicator top-indicator"></div>
  <div id="bottomIndicator" class="range-indicator bottom-indicator"></div>
  <div id="topRangeLine" class="range-line"></div>
  <div id="bottomRangeLine" class="range-line"></div>

  <!-- Position-based Notification -->
  <div id="positionNotify" class="position-notify"></div>

  <!-- Full Screen Popup -->
  <div id="fullscreenPopup" class="fullscreen-popup-backdrop">
    <div class="fullscreen-popup-container">
      <div class="fullscreen-popup-header">
        <h2>Popup Title</h2>
        <div id="cacheInfo" style="display: none; flex: 1; text-align: center; font-size: 12px; color: #666; padding: 0 20px;">
          Sessions are stored temporarily in your browser cache - download to PC for permanent storage.
        </div>
        <div class="fullscreen-popup-nav" id="diffNav" style="display: none;">
          <button onclick="app.diffCheck.prevDiff()">← Prev</button>
          <button onclick="app.diffCheck.nextDiff()">Next →</button>
          <span id="diffNavInfo" style="margin-left: 12px;">1 of 1</span>
          <span style="margin-left: 20px; display: flex; gap: 4px; align-items: center;">
            <button onclick="app.diffCheck.decreaseFontSize()" style="width: 28px; padding: 4px;">−</button>
            <button onclick="app.diffCheck.increaseFontSize()" style="width: 28px; padding: 4px;">+</button>
          </span>
          <textarea id="archiveHtmlInput" class="find-input" placeholder="Paste or drop Archived HTML here..." style="width: 250px; margin-left: 20px; min-height: 32px;"></textarea>
        </div>
        <button class="fullscreen-popup-close" onclick="app.fullscreenPopup.hide()" aria-label="Close">×</button>
      </div>
      <div class="fullscreen-popup-content">
        <!-- Content will go here -->
      </div>
    </div>
  </div>

  <!-- ⦿ Section - Code Editor Section (Tabs and Textareas) -->
  <div class="editor-section">
    <div class="editor-tabs">
      <button class="tab active" onclick="app.tabs.switch('html')">HTML</button>
      <button class="tab" onclick="app.tabs.switch('css')">CSS</button>
      <button class="tab" onclick="app.tabs.switch('js')">JavaScript</button>
    </div>

    <div class="editor-container">
      <textarea id="htmlEditor" class="editor active" placeholder="&lt;!-- Write your HTML here --&gt;" spellcheck="false">&lt;div class="container"&gt;
  &lt;h1&gt;Hello World!&lt;/h1&gt;
  &lt;p&gt;Welcome to the code editor.&lt;/p&gt;
  &lt;button onclick="showMessage()"&gt;Click Me&lt;/button&gt;
&lt;/div&gt;</textarea>

      <textarea id="cssEditor" class="editor" placeholder="/* Write your CSS here */" spellcheck="false">.container {
  text-align: center;
  padding: 50px;
  font-family: Arial, sans-serif;
}

h1 {
  margin-bottom: 20px;
}

button {
  padding: 10px 20px;
  font-size: 16px;
  cursor: pointer;
}</textarea>

      <textarea id="jsEditor" class="editor" placeholder="// Write your JavaScript here" spellcheck="false">function showMessage() {
  alert('Hello from the code editor!');
}</textarea>
    </div>
  </div>

  <!-- ⦿ Section - Preview Section (Live Preview Frame) -->

  <div class="preview-section">
    <div class="preview-header">
      <span>Preview</span>
      <div style="display: flex; align-items: center; gap: 16px; margin-left: auto;">
        <div class="auto-run-container" style="margin: 0;">
          <input type="checkbox" id="autoRun" checked="">
          <label for="autoRun" style="color: #000;">Auto-run</label>
        </div>
        <button id="runBtn" onclick="app.preview.runCode()" style="padding: 4px 12px; font-size: 12px;">Run</button>
      </div>
    </div>
    <div class="preview-container">
      <iframe id="preview"></iframe>
    </div>
  </div>
</div>

<!-- ⦿ Section - Footer Bar -->
<div class="footer-bar">
  <span class="footer-text">v1.0.<!--{{### Version Here}}-->630<!-- {{Version Title Start}}--> - Adding explanation to Cache modal (V1 moved to top)<!-- {{Version Title End}}--> | MIT License | Anything you make belongs to you. | © 2025 HarrisXR LLC</span>
</div>
    <!-- ========== END HTML CONTENT ========== -->
    
    <!-- ========== JAVASCRIPT ========== -->
    <script>
const app = {

  github: {
    async uploadToGitHub(repoPath, token, commitMessage) {
      try {
        // Parse repo path (format: owner/repo)
        const [owner, repo] = repoPath.split('/');
        if (!owner || !repo) {
          throw new Error('Invalid repository path format. Use: owner/repo');
        }

        // Get the merged HTML content
        const content = app.clipboard.getMergedHtml();

        // Convert to base64
        const base64Content = btoa(unescape(encodeURIComponent(content)));

        // GitHub API endpoint
        const apiUrl = `https://api.github.com/repos/${owner}/${repo}/contents/index.html`;

        // First, try to get the current file to obtain its SHA (if it exists)
        let sha = null;
        try {
          const getResponse = await fetch(apiUrl, {
            headers: {
              'Authorization': `token ${token}`,
              'Accept': 'application/vnd.github.v3+json'
            }
          });

          if (getResponse.ok) {
            const fileData = await getResponse.json();
            sha = fileData.sha;
          }
        } catch (e) {
          // File doesn't exist, that's okay
        }

        // Prepare the request body
        const requestBody = {
          message: commitMessage || 'Update index.html via Catamaran Coder',
          content: base64Content
        };

        // Include SHA if file exists (required for updates)
        if (sha) {
          requestBody.sha = sha;
        }

        // Upload the file
        const response = await fetch(apiUrl, {
          method: 'PUT',
          headers: {
            'Authorization': `token ${token}`,
            'Accept': 'application/vnd.github.v3+json',
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.message || `GitHub API error: ${response.status}`);
        }

        const result = await response.json();
        return result;

      } catch (error) {
        console.error('GitHub upload error:', error);
        throw error;
      }
    },

    show() {
      // Show the popup with GitHub upload form
      app.fullscreenPopup.show();

      // Build the GitHub upload form
      const content = [
        '<div style="max-width: 500px; margin: 0 auto;">',
        '<h3 style="margin-bottom: 20px; color: #000;">Upload to GitHub</h3>',
        '<div style="margin-bottom: 20px;">',
        '<label for="githubRepoInput" style="display: block; margin-bottom: 8px; font-weight: 500; color: #666;">Repository Path:</label>',
        '<input type="text" id="githubRepoInput" placeholder="owner/repository" ',
        'name="github-repository" autocomplete="username" ',
        'style="width: 100%; padding: 8px 12px; font-size: 14px; border: 1px solid #d1d1d1; border-radius: 4px; font-family: inherit;" />',
        '<div style="margin-top: 4px; font-size: 12px; color: #999;">Format: username/repository-name</div>',
        '</div>',
        '<div style="margin-bottom: 20px;">',
        '<label for="githubTokenInput" style="display: block; margin-bottom: 8px; font-weight: 500; color: #666;">',
        'Personal Access Token (Classic):',
        '</label>',
        '<input type="password" id="githubTokenInput" placeholder="ghp_xxxxxxxxxxxx" ',
        'name="github-token" autocomplete="current-password" ',
        'style="width: 100%; padding: 8px 12px; font-size: 14px; border: 1px solid #d1d1d1; border-radius: 4px; font-family: inherit;" />',
        '<div style="margin-top: 4px; font-size: 12px; color: #999;">',
        'Requires "repo" scope. Token is not stored - use a password manager for security. ',
        '<a href="https://github.com/settings/tokens/new" target="_blank" style="color: #0066cc;">Create token</a>',
        '</div>',
        '</div>',
        '<div style="margin-bottom: 20px;">',
        '<label for="githubMessageInput" style="display: block; margin-bottom: 8px; font-weight: 500; color: #666;">',
        'Commit Message (optional):',
        '</label>',
        '<input type="text" id="githubMessageInput" placeholder="V### - Version Title" ',
        'style="width: 100%; padding: 8px 12px; font-size: 14px; border: 1px solid #d1d1d1; border-radius: 4px; font-family: inherit;" />',
        '</div>',
        '<div style="display: flex; gap: 12px; justify-content: flex-end;">',
        '<button onclick="app.fullscreenPopup.hide()" ',
        'style="padding: 8px 24px; background: #fff; color: #666; border: 1px solid #d1d1d1; border-radius: 4px; cursor: pointer; font-size: 14px; transition: all 0.15s;"',
        ' onmouseover="this.style.borderColor=\'#666\'; this.style.background=\'#fafafa\'"',
        ' onmouseout="this.style.borderColor=\'#d1d1d1\'; this.style.background=\'#fff\'">Cancel</button>',
        '<button onclick="app.github.upload()" ',
        'style="padding: 8px 24px; background: #0066cc; color: #fff; border: 1px solid #0066cc; border-radius: 4px; cursor: pointer; font-size: 14px; transition: all 0.15s;"',
        ' onmouseover="this.style.background=\'#0052a3\'"',
        ' onmouseout="this.style.background=\'#0066cc\'">Upload to GitHub</button>',
        '</div>',
        '<div id="githubStatus" style="margin-top: 20px; padding: 12px; border-radius: 4px; display: none;"></div>',
        '</div>'
      ].join('');

      app.fullscreenPopup.setContent('GitHub Upload', content);

      // Load saved values from localStorage if they exist
      setTimeout(() => {
        const savedRepo = localStorage.getItem('catamaranCoder_githubRepo');
        // Token not loaded from storage - rely on password managers for security

        if (savedRepo) {
          document.getElementById('githubRepoInput').value = savedRepo;
        }

        // Auto-populate commit message with version info

        const htmlContent = app.elements.editors.html.value;

        let commitMessage = 'Update index.html';

        // Extract version number

        let versionNumber = '';

        const versionMatch = htmlContent.match(/<!--\{\{### Version Here\}\}-->(\d+)/);

        if (versionMatch && versionMatch[1]) {

          versionNumber = versionMatch[1];

        }

        // Extract version title

        let versionTitle = '';

        const titleMatch = htmlContent.match(/<!--\s*\{\{Version Title Start\}\}\s*-->([\s\S]*?)<!--\s*\{\{Version Title End\}\}\s*-->/);

        if (titleMatch && titleMatch[1]) {

          versionTitle = titleMatch[1];

        }

        // Build commit message

        if (versionNumber || versionTitle) {

          if (versionNumber && versionTitle) {

            commitMessage = `V${versionNumber}${versionTitle}`;

          } else if (versionNumber) {

            commitMessage = `V${versionNumber} - Update index.html`;

          } else if (versionTitle) {

            commitMessage = versionTitle.trim();

          }

        }

        document.getElementById('githubMessageInput').value = commitMessage;

        // Focus the repo input
        document.getElementById('githubRepoInput').focus();
      }, 100);
    },

    async upload() {
      const repoInput = document.getElementById('githubRepoInput');
      const tokenInput = document.getElementById('githubTokenInput');
      const messageInput = document.getElementById('githubMessageInput');
      const statusDiv = document.getElementById('githubStatus');

      const repoPath = repoInput.value.trim();
      const token = tokenInput.value.trim();
      const commitMessage = messageInput.value.trim();

      // Validate inputs
      if (!repoPath) {
        this.showStatus('Please enter a repository path', 'error');
        repoInput.focus();
        return;
      }

      if (!token) {
        this.showStatus('Please enter your Personal Access Token', 'error');
        tokenInput.focus();
        return;
      }

      // Save only repo path to localStorage (NOT the token for security)
      localStorage.setItem('catamaranCoder_githubRepo', repoPath);
      // Token is intentionally not stored - users should use password managers

      // Show loading status
      this.showStatus('Uploading to GitHub...', 'loading');

      try {
        const result = await this.uploadToGitHub(repoPath, token, commitMessage);

        // Success!
        const fileUrl = result.content.html_url;
        const pagesUrl = `https://${repoPath.split('/')[0]}.github.io/${repoPath.split('/')[1]}/`;

        this.showStatus(
          `Successfully uploaded! <br>` +
          `<a href="${fileUrl}" target="_blank" style="color: #0066cc;">View on GitHub</a> | ` +
          `<a href="${pagesUrl}" target="_blank" style="color: #0066cc;">View on GitHub Pages</a>`,
          'success'
        );

        // Also show notification on the GitHub button
        setTimeout(() => {
          app.notify.show(document.getElementById('githubBtn'), 'Uploaded successfully!', 'info', 'bottom');
        }, 100);

      } catch (error) {
        // Error handling
        let errorMessage = error.message;

        // Provide more helpful error messages
        if (errorMessage.includes('401')) {
          errorMessage = 'Invalid token or insufficient permissions. Make sure your token has "repo" scope.';
        } else if (errorMessage.includes('404')) {
          errorMessage = 'Repository not found. Check the repository path.';
        } else if (errorMessage.includes('422')) {
          errorMessage = 'Unable to update file. The repository might be protected or the path is invalid.';
        }

        this.showStatus(errorMessage, 'error');
      }
    },

    showStatus(message, type) {
      const statusDiv = document.getElementById('githubStatus');
      if (!statusDiv) return;

      statusDiv.style.display = 'block';
      statusDiv.innerHTML = message;

      // Style based on type
      if (type === 'loading') {
        statusDiv.style.background = '#e6f3ff';
        statusDiv.style.color = '#0066cc';
        statusDiv.style.border = '1px solid #b3d9ff';
      } else if (type === 'success') {
        statusDiv.style.background = '#e6ffe6';
        statusDiv.style.color = '#008800';
        statusDiv.style.border = '1px solid #b3ffb3';
      } else if (type === 'error') {
        statusDiv.style.background = '#ffe6e6';
        statusDiv.style.color = '#cc0000';
        statusDiv.style.border = '1px solid #ffb3b3';
      }
    }
  },

  storeAs: {

    // Helper function to extract title from HTML content
    extractTitleFromHtml(htmlContent) {
      if (!htmlContent) return '';

      const titleMatch = htmlContent.match(/<title[^>]*>([\s\S]*?)<\/title>/i);
      if (titleMatch && titleMatch[1]) {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = titleMatch[1];
        const extractedTitle = (tempDiv.textContent || tempDiv.innerText || '').trim();
        return extractedTitle || '';
      }
      return '';
    },

    // Method to copy version tags to clipboard
    copyTags() {
      const tags = '<!--{{### Version Here}}-->\n<!-- {{Version Title Start}}--><!-- {{Version Title End}}-->';

      navigator.clipboard.writeText(tags).then(() => {
        // Find and notify on the Copy Tags button
        setTimeout(() => {
          const copyTagsBtns = document.querySelectorAll('button');
          copyTagsBtns.forEach(btn => {
            if (btn.textContent === 'Copy Tags') {
              app.notify.show(btn, 'Copied Version ### and Title Tags to clipboard!', 'info', 'bottom');
            }
          });
        }, 50);
      }).catch(err => {
        console.error('Failed to copy tags:', err);
        setTimeout(() => {
          const copyTagsBtns = document.querySelectorAll('button');
          copyTagsBtns.forEach(btn => {
            if (btn.textContent === 'Copy Tags') {
              app.notify.show(btn, 'Copy failed', 'info', 'bottom');
            }
          });
        }, 50);
      });
    },

    // Method to extract version and title from HTML and fill Session Name
    fillName() {
      // Get current HTML content
      const htmlContent = app.elements.editors.html.value;

      // Extract version number after {{### Version Here}} tag
      let versionNumber = '';
      const versionMatch = htmlContent.match(/<!--\{\{### Version Here\}\}-->(\d+)/);
      if (versionMatch && versionMatch[1]) {
        versionNumber = versionMatch[1];
      }

      // Extract title between Version Title tags
      let versionTitle = '';
      const titleMatch = htmlContent.match(/<!--\s*\{\{Version Title Start\}\}\s*-->([\s\S]*?)<!--\s*\{\{Version Title End\}\}\s*-->/);
      if (titleMatch && titleMatch[1]) {
        versionTitle = titleMatch[1]; // Don't trim to preserve leading/trailing spaces
      }

      // Set the Session Name input
      const sessionNameInput = document.getElementById('sessionNameInput');
      if (sessionNameInput) {
        if (versionNumber || versionTitle) {
          // Build the session name
          let sessionName = '';
          if (versionNumber) {
            sessionName = 'V' + versionNumber;
          }
          if (versionTitle) {
            sessionName += versionTitle;
          }

          sessionNameInput.value = sessionName;

          // Show success notification
          setTimeout(() => {
            const fillButtons = document.querySelectorAll('button');
            fillButtons.forEach(btn => {
              if (btn.textContent === 'Fill Name') {
                app.notify.show(btn, 'Name filled from HTML tags', 'info', 'bottom');
              }
            });
          }, 50);
        } else {
          // No version tags found
          setTimeout(() => {
            const fillButtons = document.querySelectorAll('button');
            fillButtons.forEach(btn => {
              if (btn.textContent === 'Fill Name') {
                app.notify.show(btn, 'No version tags found in HTML', 'info', 'bottom');
              }
            });
          }, 50);
        }
      }
    },

    show(autoIncrement = true) {
      // Show the popup with Store As content
      app.fullscreenPopup.show();

      // Get existing sessions
      const sessions = this.getStoredSessions();
      const sessionNames = Object.keys(sessions).sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));

      // Build the sessions list HTML
      let sessionsList = '';
      if (sessionNames.length > 0) {
        // Build session items separately to avoid nested template literal issues
        const sessionItems = sessionNames.map(name => {
          const session = sessions[name];
          const date = new Date(session.lastModified || session.timestamp);
          const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
          const escapedName = name.replace(/'/g, '\\\\');

          // Calculate size of this session
          const sessionSize = new Blob([JSON.stringify(session)]).size;
          const sizeKB = (sessionSize / 1024).toFixed(1);

          // Extract title from HTML content
          let htmlTitle = '';
          const extractedTitle = this.extractTitleFromHtml(session.content);
          if (extractedTitle) {
            htmlTitle = ' · ' + extractedTitle; // Add separator
          }

          // Build HTML with string concatenation to avoid beautify issues
          return [
            '<div class="session-item" data-session-name="' + name + '"',
            ' style="padding: 8px 12px; margin-bottom: 4px; border: 1px solid #f0f0f0; border-radius: 4px; cursor: pointer; background: #fafafa; position: relative;"',
            ' onmouseover="var trash = this.querySelector(\'.trash-icon\'); var diff = this.querySelector(\'.diff-icon\'); if(trash) trash.style.opacity=\'1\'; if(diff) diff.style.opacity=\'1\';"',
            ' onmouseout="var trash = this.querySelector(\'.trash-icon\'); var diff = this.querySelector(\'.diff-icon\'); if(trash) trash.style.opacity=\'0\'; if(diff) diff.style.opacity=\'0\';">',
            '<div onclick="app.storeAs.selectSession(\'' + escapedName + '\', this.parentElement)" style="display: flex; justify-content: space-between; align-items: center;">',
            '<div>',
            '<div style="font-size: 14px; color: #000; margin-bottom: 2px;">' + name + '<span style="color: #999; font-size: 12px;">' + htmlTitle + '</span></div>',
            '<div style="font-size: 11px; color: #666;">' + dateStr + '</div>',
            '</div>',
            '<div style="font-size: 11px; color: #999; text-align: right; margin-right: 48px;">' + sizeKB + ' KB</div>',
            '</div>',
            '<div class="diff-icon" onclick="event.stopPropagation(); app.storeAs.diffAgainstSession(\'' + escapedName + '\');"',
            ' style="position: absolute; right: 32px; top: 50%; transform: translateY(-50%); width: 20px; height: 20px; background: rgba(255, 255, 255, 0.9); border: 1px solid #d1d1d1; border-radius: 3px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 11px; transition: all 0.1s ease; opacity: 0;"',
            ' onmouseover="this.style.background=\'#f0f0f0\'; this.style.borderColor=\'#666\';"',
            ' onmouseout="this.style.background=\'rgba(255, 255, 255, 0.9)\'; this.style.borderColor=\'#d1d1d1\';"',
            ' title="Compare with Session Name field">',
            'Df',
            '</div>',
            '<div class="trash-icon" onclick="event.stopPropagation(); app.storeAs.confirmDelete(\'' + escapedName + '\');"',
            ' style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); width: 20px; height: 20px; background: rgba(255, 255, 255, 0.9); border: 1px solid #d1d1d1; border-radius: 3px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 12px; transition: all 0.1s ease; opacity: 0;"',
            ' onmouseover="this.style.background=\'#f0f0f0\'; this.style.borderColor=\'#666\';"',
            ' onmouseout="this.style.background=\'rgba(255, 255, 255, 0.9)\'; this.style.borderColor=\'#d1d1d1\';"',
            ' title="Delete session">',
            '🗑',
            '</div>',
            '</div>'
          ].join('');
        }).join('');

        sessionsList = [
          '<div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #e5e5e5;">',
          '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">',
          '<label style="font-weight: 500; color: #666;">Saved Sessions:</label>',
          '<div style="display: flex; gap: 8px;">',
          '<button onclick="app.storeAs.loadSelected()" style="padding: 4px 12px; background: #fff; color: #000; border: 1px solid #d1d1d1; border-radius: 4px; cursor: pointer; font-size: 12px; transition: all 0.15s;"',
          ' onmouseover="this.style.borderColor=\'#000\'; this.style.background=\'#fafafa\';"',
          ' onmouseout="this.style.borderColor=\'#d1d1d1\'; this.style.background=\'#fff\';">Load</button>',
          '<button onclick="app.storeAs.loadZip()" style="padding: 4px 12px; background: #fff; color: #000; border: 1px solid #d1d1d1; border-radius: 4px; cursor: pointer; font-size: 12px; transition: all 0.15s;"',
          ' onmouseover="this.style.borderColor=\'#000\'; this.style.background=\'#fafafa\';"',
          ' onmouseout="this.style.borderColor=\'#d1d1d1\'; this.style.background=\'#fff\';">Load .Zip</button>',
          '<button onclick="app.storeAs.saveAllSessions()" style="padding: 4px 12px; background: #fff; color: #000; border: 1px solid #d1d1d1; border-radius: 4px; cursor: pointer; font-size: 12px; transition: all 0.15s;"',
          ' onmouseover="this.style.borderColor=\'#000\'; this.style.background=\'#fafafa\';"',
          ' onmouseout="this.style.borderColor=\'#d1d1d1\'; this.style.background=\'#fff\';">Save .Zip</button>',
          '<button onclick="app.storeAs.clearAllSessions()" style="padding: 4px 12px; background: #fff; color: #cc0000; border: 1px solid #d1d1d1; border-radius: 4px; cursor: pointer; font-size: 12px; transition: all 0.15s;"',
          ' onmouseover="this.style.borderColor=\'#cc0000\'; this.style.background=\'#ffe5e5\';"',
          ' onmouseout="this.style.borderColor=\'#d1d1d1\'; this.style.background=\'#fff\';">Clear All</button>',
          '</div>',
          '</div>',
          '<div style="max-height: 200px; overflow-y: auto; border: 1px solid #e5e5e5; border-radius: 4px; padding: 8px;">',
          sessionItems,
          '</div>',
          '</div>'
        ].join('');
      } else {
        sessionsList = [
          '<div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #e5e5e5;">',
          '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">',
          '<label style="font-weight: 500; color: #666;">Saved Sessions:</label>',
          '<div style="display: flex; gap: 8px;">',
          '<button onclick="app.storeAs.loadSelected()" style="padding: 4px 12px; background: #fff; color: #000; border: 1px solid #d1d1d1; border-radius: 4px; cursor: pointer; font-size: 12px; transition: all 0.15s;"',
          ' onmouseover="this.style.borderColor=\'#000\'; this.style.background=\'#fafafa\';"',
          ' onmouseout="this.style.borderColor=\'#d1d1d1\'; this.style.background=\'#fff\';">Load</button>',
          '<button onclick="app.storeAs.loadZip()" style="padding: 4px 12px; background: #fff; color: #000; border: 1px solid #d1d1d1; border-radius: 4px; cursor: pointer; font-size: 12px; transition: all 0.15s;"',
          ' onmouseover="this.style.borderColor=\'#000\'; this.style.background=\'#fafafa\';"',
          ' onmouseout="this.style.borderColor=\'#d1d1d1\'; this.style.background=\'#fff\';">Load .Zip</button>',
          '<button onclick="app.storeAs.saveAllSessions()" style="padding: 4px 12px; background: #fff; color: #000; border: 1px solid #d1d1d1; border-radius: 4px; cursor: pointer; font-size: 12px; transition: all 0.15s;"',
          ' onmouseover="this.style.borderColor=\'#000\'; this.style.background=\'#fafafa\';"',
          ' onmouseout="this.style.borderColor=\'#d1d1d1\'; this.style.background=\'#fff\';">Save .Zip</button>',
          '<button onclick="app.storeAs.clearAllSessions()" style="padding: 4px 12px; background: #fff; color: #cc0000; border: 1px solid #d1d1d1; border-radius: 4px; cursor: pointer; font-size: 12px; transition: all 0.15s;"',
          ' onmouseover="this.style.borderColor=\'#cc0000\'; this.style.background=\'#ffe5e5\';"',
          ' onmouseout="this.style.borderColor=\'#d1d1d1\'; this.style.background=\'#fff\';">Clear All</button>',
          '</div>',
          '</div>',
          '<div style="padding: 20px; text-align: center; color: #999; font-size: 13px; border: 1px solid #e5e5e5; border-radius: 4px; background: #fafafa;">',
          'No saved sessions yet',
          '</div>',
          '</div>'
        ].join('');
      }

      // Build backup section
      let backupSection = '';
      const autosaveData = localStorage.getItem('catamaranCoder_editorContent');

      if (autosaveData) {
        try {
          const backup = JSON.parse(autosaveData);
          const backupSize = new Blob([autosaveData]).size;
          const sizeKB = (backupSize / 1024).toFixed(1);
          const date = new Date(backup.timestamp || Date.now());
          const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

          // Extract title from backup HTML content
          let backupTitle = '';
          if (backup.html) {
            // Try to find h1 tag first (like getMergedHtml does)
            const h1Match = backup.html.match(/<h1[^>]*>([\s\S]*?)<\/h1>/i);
            if (h1Match && h1Match[1]) {
              const tempDiv = document.createElement('div');
              tempDiv.innerHTML = h1Match[1];
              backupTitle = (tempDiv.textContent || tempDiv.innerText || '').trim();
            }
            // Fallback to h2 if no h1
            if (!backupTitle) {
              const h2Match = backup.html.match(/<h2[^>]*>([\s\S]*?)<\/h2>/i);
              if (h2Match && h2Match[1]) {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = h2Match[1];
                backupTitle = (tempDiv.textContent || tempDiv.innerText || '').trim();
              }
            }
            if (backupTitle) {
              backupTitle = ' · ' + backupTitle;
            }
          }

          backupSection = [
            '<div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #e5e5e5;">',
            '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">',
            '<label style="font-weight: 500; color: #666;">Backup:</label>',
            '<button onclick="app.storeAs.saveBackup()" style="padding: 4px 12px; background: #fff; color: #000; border: 1px solid #d1d1d1; border-radius: 4px; cursor: pointer; font-size: 12px; transition: all 0.15s;"',
            ' onmouseover="this.style.borderColor=\'#000\'; this.style.background=\'#fafafa\';"',
            ' onmouseout="this.style.borderColor=\'#d1d1d1\'; this.style.background=\'#fff\';">Save Backup</button>',
            '</div>',
            '<div style="max-height: 80px; overflow-y: auto; border: 1px solid #e5e5e5; border-radius: 4px; padding: 8px;">',
            '<div class="backup-item" data-backup="autosave"',
            ' style="padding: 8px 12px; border: 1px solid #f0f0f0; border-radius: 4px; cursor: pointer; background: #fafafa; position: relative;"',
            ' onmouseover="var trash = this.querySelector(\'.trash-icon\'); if(trash) trash.style.opacity=\'1\';"',
            ' onmouseout="var trash = this.querySelector(\'.trash-icon\'); if(trash) trash.style.opacity=\'0\';">',
            '<div onclick="app.storeAs.selectBackup(this.parentElement)" style="display: flex; justify-content: space-between; align-items: center;">',
            '<div>',
            '<div style="font-size: 14px; color: #000; margin-bottom: 2px;">Autosave Backup<span style="color: #999; font-size: 12px;">' + backupTitle + '</span></div>',
            '<div style="font-size: 11px; color: #666;">' + dateStr + '</div>',
            '</div>',
            '<div style="font-size: 11px; color: #999; text-align: right; margin-right: 24px;">' + sizeKB + ' KB</div>',
            '</div>',
            '<div class="trash-icon" onclick="event.stopPropagation(); app.storeAs.confirmDeleteBackup();"',
            ' style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); width: 20px; height: 20px; background: rgba(255, 255, 255, 0.9); border: 1px solid #d1d1d1; border-radius: 3px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 12px; transition: all 0.1s ease; opacity: 0;"',
            ' onmouseover="this.style.background=\'#f0f0f0\'; this.style.borderColor=\'#666\';"',
            ' onmouseout="this.style.background=\'rgba(255, 255, 255, 0.9)\'; this.style.borderColor=\'#d1d1d1\';"',
            ' title="Delete backup">',
            '🗑',
            '</div>',
            '</div>',
            '</div>',
            '</div>'
          ].join('');
        } catch (e) {
          // If autosave data is corrupted, show empty backup section
          backupSection = [
            '<div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #e5e5e5;">',
            '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">',
            '<label style="font-weight: 500; color: #666;">Backup:</label>',
            '<button onclick="app.storeAs.saveBackup()" style="padding: 4px 12px; background: #fff; color: #000; border: 1px solid #d1d1d1; border-radius: 4px; cursor: pointer; font-size: 12px; transition: all 0.15s;"',
            ' onmouseover="this.style.borderColor=\'#000\'; this.style.background=\'#fafafa\';"',
            ' onmouseout="this.style.borderColor=\'#d1d1d1\'; this.style.background=\'#fff\';">Save Backup</button>',
            '</div>',
            '<div style="padding: 20px; text-align: center; color: #999; font-size: 13px; border: 1px solid #e5e5e5; border-radius: 4px; background: #fafafa;">',
            'No backup available',
            '</div>',
            '</div>'
          ].join('');
        }
      } else {
        backupSection = [
          '<div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #e5e5e5;">',
          '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">',
          '<label style="font-weight: 500; color: #666;">Backup:</label>',
          '<button onclick="app.storeAs.saveBackup()" style="padding: 4px 12px; background: #fff; color: #000; border: 1px solid #d1d1d1; border-radius: 4px; cursor: pointer; font-size: 12px; transition: all 0.15s;"',
          ' onmouseover="this.style.borderColor=\'#000\'; this.style.background=\'#fafafa\';"',
          ' onmouseout="this.style.borderColor=\'#d1d1d1\'; this.style.background=\'#fff\';">Save Backup</button>',
          '</div>',
          '<div style="padding: 20px; text-align: center; color: #999; font-size: 13px; border: 1px solid #e5e5e5; border-radius: 4px; background: #fafafa;">',
          'No backup available',
          '</div>',
          '</div>'
        ].join('');
      }

      // Get storage info
      const storageInfo = this.getStorageInfo();
      let storageIndicator = '';

      if (storageInfo) {
        storageIndicator = [
          '<div style="margin-top: 6px; text-align: right;">',
          '<span style="font-size: 11px; color: ' + storageInfo.color + ';">',
          storageInfo.usedMB + ' MB / ' + storageInfo.maxMB + ' MB',
          '</span>',
          '</div>'
        ].join('');
      }

      // Build the Store As form content using array join to avoid template literal issues
      const content = [
        '<div style="max-width: 500px; margin: 0 auto;">',
        '<div style="margin-bottom: 20px;">',
        '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">',
        '<label for="sessionNameInput" style="font-weight: 500; color: #666;">Session Name:</label>',
        '<div style="display: flex; gap: 8px;">',
        '<button onclick="app.storeAs.fillName()" style="padding: 4px 12px; background: #fff; color: #000; border: 1px solid #d1d1d1; border-radius: 4px; cursor: pointer; font-size: 12px; transition: all 0.15s;"',
        ' onmouseover="this.style.borderColor=\'#000\'; this.style.background=\'#fafafa\'"',
        ' onmouseout="this.style.borderColor=\'#d1d1d1\'; this.style.background=\'#fff\'">Fill Name</button>',
        '<button onclick="app.storeAs.copyHTML()" style="padding: 4px 12px; background: #fff; color: #000; border: 1px solid #d1d1d1; border-radius: 4px; cursor: pointer; font-size: 12px; transition: all 0.15s;"',
        ' onmouseover="this.style.borderColor=\'#000\'; this.style.background=\'#fafafa\'"',
        ' onmouseout="this.style.borderColor=\'#d1d1d1\'; this.style.background=\'#fff\'">Copy HTML</button>',
        '<button onclick="app.storeAs.saveToPC()" style="padding: 4px 12px; background: #fff; color: #000; border: 1px solid #d1d1d1; border-radius: 4px; cursor: pointer; font-size: 12px; transition: all 0.15s;"',
        ' onmouseover="this.style.borderColor=\'#000\'; this.style.background=\'#fafafa\'"',
        ' onmouseout="this.style.borderColor=\'#d1d1d1\'; this.style.background=\'#fff\'">Save to PC</button>',
        '</div>',
        '</div>',
        '<div style="position: relative; width: 100%;">',
        '<input type="text" id="sessionNameInput" placeholder="Enter session name..." style="width: 100%; padding: 8px 150px 8px 12px; font-size: 14px; border: 1px solid #d1d1d1; border-radius: 4px; font-family: inherit;" />',
        '<span id="sessionTitleDisplay" style="position: absolute; right: 12px; top: 50%; transform: translateY(-50%); color: #999; font-size: 12px; pointer-events: none; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 140px;"></span>',
        '</div>',
        '</div>',
        '<div style="display: flex; gap: 12px; justify-content: flex-end; flex-wrap: wrap; align-items: center;">',
        '<button onclick="app.storeAs.copyTags()" style="padding: 4px 12px; background: #fff; color: #000; border: 1px solid #d1d1d1; border-radius: 4px; cursor: pointer; font-size: 12px; transition: all 0.15s;"',
        ' onmouseover="this.style.borderColor=\'#000\'; this.style.background=\'#fafafa\'"',
        ' onmouseout="this.style.borderColor=\'#d1d1d1\'; this.style.background=\'#fff\'"',
        ' data-tooltip="Copies the tags to the clipboard" data-tooltip-pos="bottom">Copy Tags</button>',
        '<label style="display: flex; align-items: center; gap: 6px; font-size: 13px; color: #666; cursor: pointer;" data-tooltip="Updates {{### Version Here}} and {{Version Title Start/End}} tags" data-tooltip-pos="bottom">',
        '<input type="checkbox" id="updateVersionCheckbox" checked style="cursor: pointer;">',
        'Update ### Version',
        '</label>',
        '<button onclick="app.storeAs.store(this)" style="padding: 8px 24px; background: #fff; color: #000; border: 1px solid #d1d1d1; border-radius: 4px; cursor: pointer; font-size: 14px; transition: all 0.15s;"',
        ' onmouseover="this.style.borderColor=\'#000\'; this.style.background=\'#fafafa\'"',
        ' onmouseout="this.style.borderColor=\'#d1d1d1\'; this.style.background=\'#fff\'">Save Session</button>',
        '</div>',
        sessionsList,
        storageIndicator,
        backupSection,
        '</div>'
      ].join('');

      app.fullscreenPopup.setContent('Cache', content);
      
      // Show the cache info in header
      const cacheInfo = document.getElementById('cacheInfo');
      if (cacheInfo) {
        cacheInfo.style.display = 'block';
      }

      // Auto-scroll sessions list to bottom by default
      setTimeout(() => {
        const sessionsContainer = document.querySelector('.fullscreen-popup-content div[style*="max-height: 200px"]');
        if (sessionsContainer) {
          sessionsContainer.scrollTop = sessionsContainer.scrollHeight;
        }
      }, 50);

      // Set the suggested version name and display current title
      setTimeout(() => {
        // Skip auto-increment if requested
        if (!autoIncrement) {
          return;
        }

        const input = document.getElementById('sessionNameInput');
        const titleDisplay = document.getElementById('sessionTitleDisplay');

        // Get current document title from HTML editor
        if (titleDisplay) {
          const htmlContent = app.elements.editors.html.value;
          let docTitle = 'Untitled';

          // Try to find h1 tag first
          const h1Match = htmlContent.match(/<h1[^>]*>([\s\S]*?)<\/h1>/i);
          if (h1Match && h1Match[1]) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = h1Match[1];
            const extractedTitle = (tempDiv.textContent || tempDiv.innerText || '').trim();
            if (extractedTitle) {
              docTitle = extractedTitle;
            }
          }

          // Fallback to h2 if no h1
          if (docTitle === 'Untitled') {
            const h2Match = htmlContent.match(/<h2[^>]*>([\s\S]*?)<\/h2>/i);
            if (h2Match && h2Match[1]) {
              const tempDiv = document.createElement('div');
              tempDiv.innerHTML = h2Match[1];
              const extractedTitle = (tempDiv.textContent || tempDiv.innerText || '').trim();
              if (extractedTitle) {
                docTitle = extractedTitle;
              }
            }
          }

          titleDisplay.textContent = '· ' + docTitle;
        }

        if (input) {
          // Get and set the next version name
          const nextVersionName = this.getNextVersionName();
          if (nextVersionName) {
            input.value = nextVersionName;

            // Smart selection logic
            const openParen = nextVersionName.indexOf('(');

            if (openParen !== -1) {
              // Priority 1: Found opening parenthesis
              const closeParen = nextVersionName.indexOf(')', openParen);

              if (closeParen !== -1) {
                // Select text from after '(' to before ')'
                input.setSelectionRange(openParen + 1, closeParen);
              } else {
                // No closing paren, select from after '(' to end
                input.setSelectionRange(openParen + 1, nextVersionName.length);
              }
            } else {
              // No parenthesis, check for dash separators
              let dashIndex = nextVersionName.indexOf(' - ');

              if (dashIndex === -1) {
                // Try other dash variants
                dashIndex = nextVersionName.indexOf('-');
                if (dashIndex !== -1) {
                  // Check if it's part of V### pattern (we don't want to select from there)
                  const beforeDash = nextVersionName.substring(0, dashIndex);
                  if (beforeDash.match(/^V\d{3}$/)) {
                    dashIndex = -1; // Ignore this dash, it's part of version
                  }
                }
              }

              if (dashIndex === -1) {
                dashIndex = nextVersionName.indexOf(' -');
              }

              if (dashIndex !== -1) {
                // Priority 2: Found dash separator
                // Find where to start selection (after the dash and any spaces)
                let startPos = dashIndex + 1;
                while (startPos < nextVersionName.length &&
                  (nextVersionName[startPos] === '-' || nextVersionName[startPos] === ' ')) {
                  startPos++;
                }
                input.setSelectionRange(startPos, nextVersionName.length);
              } else {
                // Priority 3: No dash, check for space after V###
                const versionMatch = nextVersionName.match(/^V\d{3}\s+/);
                if (versionMatch) {
                  // Select everything after the V### and space(s)
                  input.setSelectionRange(versionMatch[0].length, nextVersionName.length);
                }
              }
            }

            // Show tooltip when we successfully selected text for editing
            if (input.selectionStart !== input.selectionEnd) {
              app.notify.show(input, "V### +1'd, now what didja change?", 'info', 'bottom');
            }
          }
          input.focus();
        }
      }, 100);

      // Add Enter key support for the input field
      setTimeout(() => {
        const input = document.getElementById('sessionNameInput');
        if (input) {
          input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
              app.storeAs.store();
            }
          });
        }
      }, 100);
    },

    store(buttonElement) {
      const sessionName = document.getElementById('sessionNameInput').value.trim();

      // Validate session name
      if (!sessionName) {
        app.notify.show(document.getElementById('sessionNameInput'), 'Please enter a session name', 'info', 'bottom');
        return;
      }

      try {
        // Get existing sessions from localStorage
        const existingSessions = JSON.parse(localStorage.getItem('catamaranCoder_sessions') || '{}');

        // Check if session name already exists
        if (existingSessions[sessionName]) {
          if (!confirm(`Session "${sessionName}" already exists. Overwrite?`)) {
            return;
          }
        }

        // Get the combined HTML/CSS/JS
        const mergedHtml = app.clipboard.getMergedHtml();

        // Create session object with metadata
        const session = {
          name: sessionName,
          content: mergedHtml,
          timestamp: Date.now(),
          lastModified: Date.now(),
          version: '1.0.0'
        };

        // Add to sessions collection
        existingSessions[sessionName] = session;

        // Save to localStorage
        localStorage.setItem('catamaranCoder_sessions', JSON.stringify(existingSessions));

        // Refresh the modal to show the new session in the list without auto-increment
        this.show(false);

        // Restore the session name in the input field
        setTimeout(() => {
          const input = document.getElementById('sessionNameInput');
          if (input) {
            input.value = sessionName;
            input.select(); // Select the text for easy modification
          }

          // Find and scroll to the sessions list container
          const sessionsContainer = document.querySelector('.fullscreen-popup-content div[style*="max-height: 200px"]');
          if (sessionsContainer) {
            // Scroll to bottom to show the newly added session
            sessionsContainer.scrollTop = sessionsContainer.scrollHeight;

            // Select the newly saved session
            const newSessionElement = document.querySelector(`.session-item[data-session-name="${sessionName}"]`);
            if (newSessionElement) {
              app.storeAs.selectSession(sessionName, newSessionElement);
            }
          }

          // Show success notification on the Save Session button after modal refresh
          // We need to find the button again since the modal was rebuilt
          const saveButtons = document.querySelectorAll('button');
          saveButtons.forEach(btn => {
            if (btn.textContent === 'Save Session' && btn.onclick && btn.onclick.toString().includes('store')) {
              app.notify.show(btn, `${sessionName} saved!`, 'info', 'bottom');
            }
          });
        }, 100);

        console.log(`Session "${sessionName}" stored successfully`);

      } catch (error) {
        console.error('Failed to store session:', error);

        // Check if it's a quota exceeded error
        if (error.name === 'QuotaExceededError') {
          const notifyElement = buttonElement || document.getElementById('sessionNameInput');
          app.notify.show(notifyElement, 'Storage full - please delete old sessions', 'info', 'bottom');
        } else {
          const notifyElement = buttonElement || document.getElementById('sessionNameInput');
          app.notify.show(notifyElement, 'Failed to save session', 'info', 'bottom');
        }
      }
    },

    // Method to load sessions from a ZIP file
    loadZip() {
      // Check if JSZip is loaded
      if (!window.JSZip) {
        // Load JSZip library first
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
        script.onload = () => {
          // Retry after loading
          this.loadZip();
        };
        script.onerror = () => {
          app.notify.show(document.getElementById('sessionNameInput'), 'Failed to load ZIP library', 'info', 'bottom');
        };
        document.head.appendChild(script);

        // Show loading message
        setTimeout(() => {
          const loadZipBtns = document.querySelectorAll('button');
          loadZipBtns.forEach(btn => {
            if (btn.textContent === 'Load .Zip') {
              app.notify.show(btn, 'Loading library...', 'info', 'bottom');
            }
          });
        }, 50);
        return;
      }

      // Create a file input element
      const fileInput = document.createElement('input');
      fileInput.type = 'file';
      fileInput.accept = '.zip';

      fileInput.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        try {
          // Read the ZIP file first to see what's in it
          const zip = new JSZip();
          const content = await zip.loadAsync(file);

          // Count HTML files in the ZIP
          let htmlFileCount = 0;
          for (let filename in content.files) {
            if (!content.files[filename].dir && filename.toLowerCase().endsWith('.html')) {
              htmlFileCount++;
            }
          }

          if (htmlFileCount === 0) {
            app.notify.show(document.getElementById('sessionNameInput'), 'No HTML files found in ZIP', 'info', 'bottom');
            return;
          }

          // Get existing sessions count
          const existingSessions = this.getStoredSessions();
          const existingCount = Object.keys(existingSessions).length;

          // Ask for confirmation
          let confirmMessage = `Found ${htmlFileCount} HTML file${htmlFileCount > 1 ? 's' : ''} in the ZIP.\n\n`;
          if (existingCount > 0) {
            confirmMessage += `This will CLEAR all ${existingCount} existing session${existingCount > 1 ? 's' : ''} and replace them with the ZIP contents.\n\n`;
          }
          confirmMessage += 'Are you sure you want to continue?';

          if (!confirm(confirmMessage)) {
            return;
          }

          // Clear existing sessions since user confirmed
          const clearedSessions = {};
          let importedCount = 0;
          let skippedCount = 0;

          // Process each file in the ZIP
          for (let filename in content.files) {
            const zipFile = content.files[filename];

            // Only process HTML files (not directories)
            if (!zipFile.dir && filename.toLowerCase().endsWith('.html')) {
              try {
                // Extract the content
                const htmlContent = await zipFile.async('string');

                // Clean up the filename to create a session name
                let sessionName = filename.replace(/\.html?$/i, '');

                // Only replace underscores with spaces if they look like word separators
                // Keep original casing and safe special characters
                // Windows/Mac safe: letters, numbers, spaces, hyphens, parentheses, periods (not at end)

                // If filename has no spaces but has underscores, assume underscores are spaces
                if (!sessionName.includes(' ') && sessionName.includes('_')) {
                  sessionName = sessionName.replace(/_/g, ' ');
                }

                // Preserve the original format as much as possible
                // Only clean up truly unsafe characters for Windows/Mac filesystems
                // Keep: spaces, hyphens, parentheses, periods (except trailing)
                sessionName = sessionName
                  .replace(/[<>:"|\\/?*]/g, '') // Remove truly unsafe characters
                  .replace(/\.+$/, '') // Remove trailing periods
                  .trim();

                // Check for duplicates within the ZIP itself
                if (clearedSessions[sessionName]) {
                  // Generate a unique name by appending a number
                  let counter = 2;
                  let uniqueName = `${sessionName} (${counter})`;
                  while (clearedSessions[uniqueName]) {
                    counter++;
                    uniqueName = `${sessionName} (${counter})`;
                  }
                  sessionName = uniqueName;
                }

                // Create session object
                const session = {
                  name: sessionName,
                  content: htmlContent,
                  timestamp: Date.now(),
                  lastModified: Date.now(),
                  version: '1.0.0'
                };

                // Add to sessions
                clearedSessions[sessionName] = session;
                importedCount++;

              } catch (error) {
                console.error(`Failed to process ${filename}:`, error);
                skippedCount++;
              }
            }
          }

          // Save the new sessions to localStorage (replacing all existing)
          localStorage.setItem('catamaranCoder_sessions', JSON.stringify(clearedSessions));

          // Refresh the modal
          this.show();

          // Show result notification
          let message = '';
          if (importedCount > 0 && skippedCount > 0) {
            message = `Imported ${importedCount} session${importedCount > 1 ? 's' : ''}, ${skippedCount} skipped`;
          } else if (importedCount > 0) {
            message = `Imported ${importedCount} session${importedCount > 1 ? 's' : ''}`;
          } else {
            message = 'No HTML files found in ZIP';
          }

          setTimeout(() => {
            const loadZipBtns = document.querySelectorAll('button');
            loadZipBtns.forEach(btn => {
              if (btn.textContent === 'Load .Zip') {
                app.notify.show(btn, message, 'info', 'bottom');
              }
            });
          }, 50);

        } catch (error) {
          console.error('Failed to load ZIP:', error);
          app.notify.show(document.getElementById('sessionNameInput'), 'Failed to load ZIP file', 'info', 'bottom');
        }
      };

      // Trigger the file dialog
      fileInput.click();
    },

    // Method to generate ZIP filename with version range
    generateZipFilename(sessionNames) {
      // Get current date in YYMMDD format
      const now = new Date();
      const yy = String(now.getFullYear()).slice(-2);
      const mm = String(now.getMonth() + 1).padStart(2, '0');
      const dd = String(now.getDate()).padStart(2, '0');
      const datePrefix = `${yy}${mm}${dd}`;

      // Find version range
      const versionPattern = /^V(\d{3})/;
      const versions = [];

      sessionNames.forEach(name => {
        const match = name.match(versionPattern);
        if (match) {
          versions.push(parseInt(match[1], 10));
        }
      });

      if (versions.length > 0) {
        // Find min and max versions
        const minVersion = Math.min(...versions);
        const maxVersion = Math.max(...versions);

        // Format with leading zeros
        const minFormatted = String(minVersion).padStart(3, '0');
        const maxFormatted = String(maxVersion).padStart(3, '0');

        if (minVersion === maxVersion) {
          // Single version
          return `${datePrefix} - Catamaran - V${minFormatted}.zip`;
        } else {
          // Version range
          return `${datePrefix} - Catamaran - V${minFormatted} to V${maxFormatted}.zip`;
        }
      } else {
        // No versioned sessions
        return `${datePrefix} - Catamaran Sessions.zip`;
      }
    },

    // Method to clear all saved sessions
    clearAllSessions() {
      const sessions = this.getStoredSessions();
      const sessionCount = Object.keys(sessions).length;

      if (sessionCount === 0) {
        app.notify.show(document.getElementById('sessionNameInput'), 'No sessions to clear', 'info', 'bottom');
        return;
      }

      // Confirm deletion
      const message = sessionCount === 1 ?
        'Are you sure you want to delete 1 session?' :
        `Are you sure you want to delete all ${sessionCount} sessions?`;

      if (confirm(message)) {
        try {
          // Clear all sessions from localStorage
          localStorage.setItem('catamaranCoder_sessions', '{}');

          // Refresh the modal to show empty list
          this.show();

          // Show success notification
          setTimeout(() => {
            const clearAllBtns = document.querySelectorAll('button');
            clearAllBtns.forEach(btn => {
              if (btn.textContent === 'Clear All') {
                const msg = sessionCount === 1 ?
                  '1 session cleared' :
                  `${sessionCount} sessions cleared`;
                app.notify.show(btn, msg, 'info', 'bottom');
              }
            });
          }, 50);
        } catch (error) {
          console.error('Failed to clear sessions:', error);
          app.notify.show(document.getElementById('sessionNameInput'), 'Failed to clear sessions', 'info', 'bottom');
        }
      }
    },

    // Method to save all sessions at once
    async saveAllSessions() {
      const sessions = this.getStoredSessions();
      const sessionNames = Object.keys(sessions);

      if (sessionNames.length === 0) {
        app.notify.show(document.getElementById('sessionNameInput'), 'No sessions to save', 'info', 'bottom');
        return;
      }

      // Check if JSZip is loaded
      if (!window.JSZip) {
        // Try to load JSZip library
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
        script.onload = () => {
          // Retry after loading
          this.saveAllSessions();
        };
        script.onerror = () => {
          // Fallback: Download sessions one by one with delays
          this.saveAllSessionsSequentially();
        };
        document.head.appendChild(script);

        // Show loading message
        setTimeout(() => {
          const saveAllBtns = document.querySelectorAll('button');
          saveAllBtns.forEach(btn => {
            if (btn.textContent === 'Save .Zip') {
              app.notify.show(btn, 'Loading...', 'info', 'bottom');
            }
          });
        }, 50);
        return;
      }

      // Create a zip file
      const zip = new JSZip();

      // Add each session to the zip
      sessionNames.forEach(name => {
        const session = sessions[name];
        // Create filesystem-safe filename while preserving structure
        const filename = name
          .replace(/[<>:"|\\/?*]/g, '_') // Replace unsafe with underscore
          .replace(/\s+/g, '_') // Replace spaces with underscores
          .trim() + '.html';
        zip.file(filename, session.content);
      });

      // Generate the zip file
      zip.generateAsync({ type: 'blob' }).then(content => {
        // Generate filename with version range if applicable
        const filename = this.generateZipFilename(sessionNames);

        // Create download link
        const url = URL.createObjectURL(content);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);

        // Clean up
        setTimeout(() => URL.revokeObjectURL(url), 100);

        // Show success notification
        setTimeout(() => {
          const saveAllBtns = document.querySelectorAll('button');
          saveAllBtns.forEach(btn => {
            if (btn.textContent === 'Save .Zip') {
              app.notify.show(btn, `Saved ${sessionNames.length} sessions!`, 'info', 'bottom');
            }
          });
        }, 50);
      });
    },

    // Fallback method to save sessions sequentially
    saveAllSessionsSequentially() {
      const sessions = this.getStoredSessions();
      const sessionNames = Object.keys(sessions);
      let currentIndex = 0;

      const downloadNext = () => {
        if (currentIndex >= sessionNames.length) {
          // All done
          setTimeout(() => {
            const saveAllBtns = document.querySelectorAll('button');
            saveAllBtns.forEach(btn => {
              if (btn.textContent === 'Save .Zip') {
                app.notify.show(btn, `Saved ${sessionNames.length} sessions!`, 'info', 'bottom');
              }
            });
          }, 50);
          return;
        }

        const name = sessionNames[currentIndex];
        const session = sessions[name];
        const filename = name.replace(/[^a-z0-9]/gi, '_').toLowerCase() + '.html';

        // Create and download
        const blob = new Blob([session.content], { type: 'text/html' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);

        // Clean up
        setTimeout(() => URL.revokeObjectURL(url), 100);

        currentIndex++;
        // Download next file after a short delay
        setTimeout(downloadNext, 300);
      };

      downloadNext();
    },

    // Method to get the next version number based on existing sessions
    getNextVersionName() {
      const sessions = this.getStoredSessions();
      const sessionNames = Object.keys(sessions);

      let highestVersion = 0;
      let lastVersionSession = null;

      // Pattern to match V### at the start of session names
      const versionPattern = /^V(\d{3})(.*)/;

      sessionNames.forEach(name => {
        const match = name.match(versionPattern);
        if (match) {
          const versionNum = parseInt(match[1], 10);
          if (versionNum > highestVersion) {
            highestVersion = versionNum;
            lastVersionSession = {
              version: versionNum,
              suffix: match[2] // Everything after V###
            };
          }
        }
      });

      // If we found versioned sessions, return the next version
      if (lastVersionSession) {
        const nextVersion = highestVersion + 1;
        // Pad with zeros to maintain 3 digits
        const paddedVersion = String(nextVersion).padStart(3, '0');
        return `V${paddedVersion}${lastVersionSession.suffix}`;
      }

      return ''; // Return empty string if no versioned sessions found
    },

    // Method to copy selected session HTML to clipboard
    copyHTML() {
      const sessionName = document.getElementById('sessionNameInput').value.trim();

      if (!sessionName) {
        app.notify.show(document.getElementById('sessionNameInput'), 'Enter or select a session name', 'info', 'bottom');
        return;
      }

      let htmlContent = '';

      // Check if it's the backup being copied
      if (sessionName === 'Autosave Backup') {
        // Get the current editor content for backup
        htmlContent = app.clipboard.getMergedHtml();
      } else {
        // Get the session from storage
        const sessions = this.getStoredSessions();
        const session = sessions[sessionName];

        if (!session) {
          // Session not found in saved sessions - use current editor content
          htmlContent = app.clipboard.getMergedHtml();
        } else {
          // Use saved session content
          htmlContent = session.content;
        }
      }

      // Copy to clipboard
      navigator.clipboard.writeText(htmlContent).then(() => {
        // Find and notify on the Copy HTML button
        setTimeout(() => {
          const copyBtns = document.querySelectorAll('button');
          copyBtns.forEach(btn => {
            if (btn.textContent === 'Copy HTML') {
              app.notify.show(btn, 'Copied to clipboard!', 'info', 'bottom');
            }
          });
        }, 50);
      }).catch(err => {
        app.notify.show(document.getElementById('sessionNameInput'), 'Copy failed', 'info', 'bottom');
        console.error('Failed to copy:', err);
      });
    },

    // Method to manually save a backup
    saveBackup() {
      // Call the autosave function directly
      app.state.autoSave.saveToStorage();

      // Refresh the modal to show updated backup
      this.show();

      // Show success notification on the Save Backup button itself
      // We need to find the button that was clicked
      setTimeout(() => {
        const saveBackupBtns = document.querySelectorAll('button');
        saveBackupBtns.forEach(btn => {
          if (btn.textContent === 'Save Backup') {
            app.notify.show(btn, 'Backup saved!', 'info', 'bottom');
          }
        });
      }, 50);
    },

    // Method to save selected session to PC
    saveToPC() {
      const sessionName = document.getElementById('sessionNameInput').value.trim();

      if (!sessionName) {
        app.notify.show(document.getElementById('sessionNameInput'), 'Enter or select a session name', 'info', 'bottom');
        return;
      }

      let htmlContent = '';
      let filename = '';

      // Check if it's the backup being downloaded
      if (sessionName === 'Autosave Backup') {
        // Get the current editor content for backup
        htmlContent = app.clipboard.getMergedHtml();
        filename = 'backup_' + new Date().toISOString().slice(0, 10) + '.html';
      } else {
        // Get the session from storage
        const sessions = this.getStoredSessions();
        const session = sessions[sessionName];

        if (!session) {
          // Session not found - use current editor content with the typed name
          htmlContent = app.clipboard.getMergedHtml();
        } else {
          // Use saved session content
          htmlContent = session.content;
        }

        // Extract title from HTML content for filename prefix
        let titlePrefix = '';
        const extractedTitle = this.extractTitleFromHtml(htmlContent);
        if (extractedTitle && extractedTitle !== 'Untitled') {
          // Make title filesystem-safe
          titlePrefix = extractedTitle
            .replace(/[<>:"|\\/?*]/g, '_') // Replace unsafe with underscore
            .replace(/\s+/g, '_') // Replace spaces with underscores
            .trim() + '_';
        }

        // Create filesystem-safe filename with title prefix
        // Windows/Mac safe: Remove < > : " | \ / ? * but keep spaces, hyphens, parentheses
        const safeName = sessionName
          .replace(/[<>:"|\\/?*]/g, '_') // Replace unsafe with underscore
          .replace(/\s+/g, '_') // Replace spaces with underscores for filename
          .trim();

        filename = titlePrefix + safeName + '.html';
      }

      // Create a blob and download link
      const blob = new Blob([htmlContent], { type: 'text/html' });
      const url = URL.createObjectURL(blob);

      // Create temporary anchor element and trigger download
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);

      // Clean up the URL
      setTimeout(() => URL.revokeObjectURL(url), 100);

      // Show success notification
      app.notify.show(document.getElementById('storeAsBtn'), `Downloaded: ${filename}`, 'info', 'bottom');
    },

    // Method to select the backup
    selectBackup(clickedElement) {
      // Update input value without focus
      const input = document.getElementById('sessionNameInput');
      if (input) {
        input.value = 'Autosave Backup';
      }

      // Update selection styling with optimized approach
      if (clickedElement) {
        // Cache the current selected item if exists
        const currentSelected = document.querySelector('.session-item[data-selected="true"], .backup-item[data-selected="true"]');

        // Remove selection from previous item only
        if (currentSelected && currentSelected !== clickedElement) {
          currentSelected.style.background = '#fafafa';
          currentSelected.style.borderColor = '#f0f0f0';
          currentSelected.removeAttribute('data-selected');
        }

        // Add selection to clicked backup
        clickedElement.style.background = '#e5e5e5';
        clickedElement.style.borderColor = '#666';
        clickedElement.setAttribute('data-selected', 'true');
      }
    },

    // Method to confirm and delete the backup
    confirmDeleteBackup() {
      if (confirm('Are you sure you want to delete the autosave backup?')) {
        try {
          localStorage.removeItem('catamaranCoder_editorContent');
          localStorage.removeItem('catamaranCoder_backup');

          // Refresh the modal
          this.show();
          app.notify.show(document.getElementById('storeAsBtn'), 'Backup deleted', 'info', 'bottom');
        } catch (error) {
          app.notify.show(document.getElementById('storeAsBtn'), 'Failed to delete backup', 'info', 'bottom');
        }
      }
    },

    // Method to load the backup
    loadBackup() {
      try {
        const autosaveData = localStorage.getItem('catamaranCoder_editorContent');
        if (!autosaveData) {
          return false;
        }

        const data = JSON.parse(autosaveData);

        // Load the backup content into editors
        if (data.html) app.elements.editors.html.value = data.html;
        if (data.css) app.elements.editors.css.value = data.css;
        if (data.js) app.elements.editors.js.value = data.js;

        // Update preview
        if (app.state.autoRun) {
          app.preview.update();
        }

        return true;
      } catch (error) {
        console.error('Failed to load backup:', error);
        return false;
      }
    },

    // Method to load the selected session
    loadSelected() {
      const sessionName = document.getElementById('sessionNameInput').value.trim();

      if (!sessionName) {
        app.notify.show(document.getElementById('sessionNameInput'), 'Enter or select a session name', 'info', 'bottom');
        return;
      }

      // Check if it's the backup being loaded
      if (sessionName === 'Autosave Backup') {
        if (this.loadBackup()) {
          // Close the modal
          app.fullscreenPopup.hide();

          // Show success notification on the Cache button
          app.notify.show(document.getElementById('storeAsBtn'), 'Backup loaded!', 'info', 'bottom');
        } else {
          app.notify.show(document.getElementById('sessionNameInput'), 'Failed to load backup', 'info', 'bottom');
        }
        return;
      }

      // Otherwise load as normal session
      if (this.loadSession(sessionName)) {
        // Close the modal
        app.fullscreenPopup.hide();

        // Show success notification on the Cache button
        app.notify.show(document.getElementById('storeAsBtn'), `Session "${sessionName}" loaded!`, 'info', 'bottom');
      } else {
        app.notify.show(document.getElementById('sessionNameInput'), `Session "${sessionName}" not found`, 'info', 'bottom');
      }
    },

    // Helper method to get all stored sessions
    getStoredSessions() {
      try {
        return JSON.parse(localStorage.getItem('catamaranCoder_sessions') || '{}');
      } catch (error) {
        console.error('Failed to retrieve sessions:', error);
        return {};
      }
    },

    // Helper method to calculate storage usage
    getStorageInfo() {
      try {
        // Calculate total localStorage usage (all keys)
        let totalSize = 0;
        for (let key in localStorage) {
          if (localStorage.hasOwnProperty(key)) {
            totalSize += new Blob([localStorage[key]]).size;
          }
        }

        // Max storage is 5MB
        const maxMB = 5.0;
        const totalMB = totalSize / (1024 * 1024);
        const usedPercent = (totalMB / maxMB) * 100;

        // Determine color based on usage
        let color = '#666'; // Default gray
        if (usedPercent >= 100) {
          color = '#cc0000'; // Red at 100%+
        } else if (usedPercent >= 80) {
          color = '#ff8800'; // Orange at 80%+
        }

        return {
          usedMB: totalMB.toFixed(2),
          maxMB: maxMB.toFixed(1),
          color: color
        };
      } catch (error) {
        console.error('Failed to calculate storage:', error);
        return null;
      }
    },

    // Helper method to delete a session
    deleteSession(sessionName) {
      try {
        const sessions = this.getStoredSessions();
        delete sessions[sessionName];
        localStorage.setItem('catamaranCoder_sessions', JSON.stringify(sessions));
        return true;
      } catch (error) {
        console.error('Failed to delete session:', error);
        return false;
      }
    },

    // Method to select a session from the list
    selectSession(sessionName, clickedElement) {
      // Update input value without focus to avoid keyboard popup on mobile and reduce lag
      const input = document.getElementById('sessionNameInput');
      if (input) {
        input.value = sessionName;
      }

      // Update selection styling with optimized approach
      if (clickedElement) {
        // Cache the current selected item if exists
        const currentSelected = document.querySelector('.session-item[data-selected="true"], .backup-item[data-selected="true"]');

        // Remove selection from previous item only (not all items)
        if (currentSelected && currentSelected !== clickedElement) {
          currentSelected.style.background = '#fafafa';
          currentSelected.style.borderColor = '#f0f0f0';
          currentSelected.removeAttribute('data-selected');
        }

        // Add selection to clicked item
        clickedElement.style.background = '#e5e5e5';
        clickedElement.style.borderColor = '#666';
        clickedElement.setAttribute('data-selected', 'true');
      }
    },

    // Method to confirm and delete a session
    confirmDelete(sessionName) {
      if (confirm(`Are you sure you want to delete "${sessionName}" from the cache?`)) {
        if (this.deleteSession(sessionName)) {
          // Refresh the modal to show updated list
          this.show();
          app.notify.show(document.getElementById('storeAsBtn'), `Session "${sessionName}" deleted`, 'info', 'bottom');
        } else {
          app.notify.show(document.getElementById('storeAsBtn'), 'Failed to delete session', 'info', 'bottom');
        }
      }
    },

    // Method to diff a session against what's in the Session Name field
    async diffAgainstSession(clickedSessionName) {
      const sessionNameField = document.getElementById('sessionNameInput').value.trim();

      if (!sessionNameField) {
        app.notify.show(document.getElementById('sessionNameInput'), 'Enter a session name to compare', 'info', 'bottom');
        return;
      }

      // Get content for the clicked session
      const sessions = this.getStoredSessions();
      const clickedSession = sessions[clickedSessionName];

      if (!clickedSession) {
        app.notify.show(document.getElementById('sessionNameInput'), 'Session not found', 'info', 'bottom');
        return;
      }

      let compareContent = '';
      let compareLabel = '';

      // Check if sessionNameField matches a saved session or backup
      if (sessionNameField === 'Autosave Backup') {
        // Get backup content
        const autosaveData = localStorage.getItem('catamaranCoder_editorContent');
        if (!autosaveData) {
          app.notify.show(document.getElementById('sessionNameInput'), 'No backup found', 'info', 'bottom');
          return;
        }
        try {
          const data = JSON.parse(autosaveData);
          const mergedHtml = '<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Backup</title>\n\n    <!-- ========== CSS STYLES ========== -->\n    <style>\n' + (data.css || '') + '\n    </style>\n    <!-- ========== END CSS STYLES ========== -->\n</head>\n<body>\n    <!-- ========== HTML CONTENT ========== -->\n    ' + (data.html || '') + '\n    <!-- ========== END HTML CONTENT ========== -->\n    \n    <!-- ========== JAVASCRIPT ========== -->\n    <script>\n' + (data.js || '') + '\n    <\/script>\n    <!-- ========== END JAVASCRIPT ========== -->\n</body>\n</html>';
          compareContent = mergedHtml;
          compareLabel = 'Autosave Backup';
        } catch (e) {
          app.notify.show(document.getElementById('sessionNameInput'), 'Failed to read backup', 'info', 'bottom');
          return;
        }
      } else if (sessions[sessionNameField]) {
        // It's a saved session
        compareContent = sessions[sessionNameField].content;
        compareLabel = sessionNameField;
      } else {
        // Assume it's the current editor content
        compareContent = app.clipboard.getMergedHtml();
        compareLabel = 'Current Editor';
      }

      // Check if diff libraries are loaded
      if (!app.diffCheck.isReady()) {
        // Load libraries but keep modal open
        const loaded = await app.diffCheck.loadLibraries(document.getElementById('sessionNameInput'));
        if (!loaded) return;
        // Tell user to click again
        app.notify.show(document.getElementById('sessionNameInput'), 'Libraries loaded - click Df again', 'info', 'bottom');
        return;
      }

      // Libraries are ready, close modal and show diff
      app.fullscreenPopup.hide();

      // Perform the diff comparison (Session Name field on left, clicked session on right)
      await app.diffCheck.compareTexts(
        compareContent,
        clickedSession.content,
        compareLabel,
        clickedSessionName,
        document.getElementById('storeAsBtn')
      );
    },

    // Helper method to load a session
    loadSession(sessionName) {
      try {
        const sessions = this.getStoredSessions();
        const session = sessions[sessionName];

        if (!session) {
          console.error('Session not found:', sessionName);
          return false;
        }

        // Load the session content into the editor
        const tempInput = document.getElementById('replaceInput');
        tempInput.value = session.content;

        // Trigger the paste functionality to parse and load the HTML
        app.clipboard.paste();

        console.log(`Session "${sessionName}" loaded successfully`);
        return true;

      } catch (error) {
        console.error('Failed to load session:', error);
        return false;
      }
    }
  },

  fullscreenPopup: {
    show() {
      const popup = document.getElementById('fullscreenPopup');
      popup.classList.add('show');
    },

    hide() {
      const popup = document.getElementById('fullscreenPopup');
      popup.classList.remove('show');

      // Hide diff navigation when closing
      const diffNav = document.getElementById('diffNav');
      diffNav.style.display = 'none';
      
      // Hide cache info when closing
      const cacheInfo = document.getElementById('cacheInfo');
      if (cacheInfo) {
        cacheInfo.style.display = 'none';
      }

      // Clear archive input when closing
      const archiveInput = document.getElementById('archiveHtmlInput');
      if (archiveInput) {
        archiveInput.value = '';
      }
    },

    setContent(headerText, contentHtml) {
      const header = document.querySelector('.fullscreen-popup-header h2');
      const content = document.querySelector('.fullscreen-popup-content');

      if (headerText) header.textContent = headerText;
      if (contentHtml) content.innerHTML = contentHtml;
    },

    init() {
      // Click backdrop to close
      const backdrop = document.getElementById('fullscreenPopup');
      backdrop.addEventListener('click', (e) => {
        if (e.target === backdrop) {
          app.fullscreenPopup.hide();
        }
      });

      // Prevent clicks inside container from closing
      const container = backdrop.querySelector('.fullscreen-popup-container');
      container.addEventListener('click', (e) => {
        e.stopPropagation();
      });
    }
  },

  loadPrism: {
    loaded: false,

    load() {
      return new Promise((resolve, reject) => {
        if (this.loaded && window.Prism) {
          resolve();
          return;
        }

        // Load Prism CSS first
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = 'https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css';
        document.head.appendChild(link);

        // Then load Prism JS
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js';
        script.onload = () => {
          // Load additional language components
          const languages = ['markup', 'css', 'javascript'];
          let loadedCount = 0;

          const checkAllLoaded = () => {
            loadedCount++;
            if (loadedCount === languages.length) {
              this.loaded = true;
              console.log('Prism library and languages loaded');
              resolve();
            }
          };

          languages.forEach(lang => {
            const langScript = document.createElement('script');
            langScript.src = `https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-${lang}.min.js`;
            langScript.onload = checkAllLoaded;
            langScript.onerror = () => {
              console.error(`Failed to load Prism ${lang} component`);
              checkAllLoaded(); // Continue anyway
            };
            document.head.appendChild(langScript);
          });
        };
        script.onerror = () => {
          console.error('Failed to load Prism');
          reject(new Error('Failed to load Prism'));
        };
        document.head.appendChild(script);
      });
    }
  },

  diffCheck: {

    currentDiffIndex: 0,
    diffPositions: [],
    currentFontSize: 7,
    minFontSize: 5,
    maxFontSize: 20,

    // Generic function to show diff between any two texts
    showDiff(text1, text2, label1 = 'Original', label2 = 'Modified', showArchiveInput = false) {
      // Show the popup
      app.fullscreenPopup.show();
      app.fullscreenPopup.setContent('Diff Check', '<p>Calculating differences...</p>');

      try {
        // Calculate diff
        const diff = window.Diff.diffLines(text1, text2);

        // Process diff to create aligned views
        const { originalLines, modifiedLines } = this.alignDiffLines(diff);

        // Build diff display with scroll container
        let diffHtml = '<div class="diff-container">';
        diffHtml += '<div class="diff-scroll-container" id="diffScrollContainer">';
        diffHtml += '<div class="diff-panels-wrapper">';

        // Original column with custom label
        diffHtml += '<div class="diff-column">';
        diffHtml += `<div class="diff-label">${label1}</div>`;
        diffHtml += '<pre class="language-javascript"><code id="diffOriginalCode">';
        originalLines.forEach((line, idx) => {
          if (line.empty) {
            diffHtml += `<span class="diff-line empty"><span class="diff-line-number">${idx + 1}</span></span>\n`;
          } else {
            const lineClass = line.removed ? 'removed' : '';
            const highlightedText = this.highlightCode(line.text);
            diffHtml += `<span class="diff-line ${lineClass}"><span class="diff-line-number">${idx + 1}</span>${highlightedText}</span>\n`;
          }
        });
        diffHtml += '</code></pre></div>';

        // Modified column with custom label
        diffHtml += '<div class="diff-column">';
        diffHtml += `<div class="diff-label">${label2}</div>`;
        diffHtml += '<pre class="language-javascript"><code id="diffModifiedCode">';
        modifiedLines.forEach((line, idx) => {
          if (line.empty) {
            diffHtml += `<span class="diff-line empty"><span class="diff-line-number">${idx + 1}</span></span>\n`;
          } else {
            const lineClass = line.added ? 'added' : '';
            const highlightedText = this.highlightCode(line.text);
            diffHtml += `<span class="diff-line ${lineClass}"><span class="diff-line-number">${idx + 1}</span>${highlightedText}</span>\n`;
          }
        });
        diffHtml += '</code></pre></div>';

        diffHtml += '</div></div></div>';

        // Update popup content
        app.fullscreenPopup.setContent('Diff Check', diffHtml);

        // Show diff navigation
        const diffNav = document.getElementById('diffNav');
        diffNav.style.display = 'flex';

        // Show/hide archive input based on parameter
        const archiveInput = document.getElementById('archiveHtmlInput');
        if (archiveInput) {
          archiveInput.style.display = showArchiveInput ? 'block' : 'none';

          if (showArchiveInput) {
            // Track the last dropped filename for success notification
            let lastDroppedFilename = null;

            // Simple handler for archive HTML files - just set the value and trigger input event
            const archiveHandler = (content, filename, element) => {
              // Store filename for success message
              lastDroppedFilename = filename;

              // Just set the content to the textarea
              element.value = content;

              // Trigger the input event to process it the same way as paste
              const event = new Event('input', { bubbles: true });
              element.dispatchEvent(event);
            };

            // Initialize drag & drop with custom handler
            app.clipboard.fileHandler.initDragDrop(archiveInput, archiveHandler);

            // Set up archive HTML input listener for both paste and programmatic changes
            archiveInput.addEventListener('input', (e) => {
              const text = e.target.value.trim();
              if (text.length > 10 && text.includes('<') && text.includes('>') &&
                (text.toLowerCase().includes('<!doctype') ||
                  text.toLowerCase().includes('<html') ||
                  text.toLowerCase().includes('<body'))) {
                // Process the archive, passing filename if it was from a drop
                app.diffCheck.updateDiffWithArchive(text, lastDroppedFilename);

                // Clear the filename after processing
                lastDroppedFilename = null;
              }
            });
          }
        }

        // Wait for DOM and highlighting
        requestAnimationFrame(() => {
          setTimeout(() => {
            const scrollContainer = document.getElementById('diffScrollContainer');
            if (scrollContainer) {
              void scrollContainer.offsetHeight;
              this.collectDiffPositions();
              if (this.diffPositions.length > 0) {
                this.scrollToDiff(0);
              }
            }
          }, 100);
        });

        // Reset font size to default
        this.currentFontSize = 7;
        this.applyFontSize();

      } catch (error) {
        app.fullscreenPopup.setContent('Error', '<p>Failed to calculate diff: ' + error.message + '</p>');
      }
    },

    // Check if libraries are loaded and ready
    isReady() {
      return app.loadDiff.loaded && app.loadPrism.loaded;
    },

    // Load required libraries
    async loadLibraries(notifyElement) {
      if (this.isReady()) {
        return true;
      }

      app.notify.show(notifyElement, 'Loading jsdiff and prism...', 'info', 'bottom');

      try {
        await app.loadDiff.load();
        await app.loadPrism.load();
        app.notify.show(notifyElement, 'Loaded successfully!', 'info', 'bottom');
        console.log('Diff Check libraries loaded successfully');
        return true;
      } catch (error) {
        app.notify.show(notifyElement, 'Failed to load libraries', 'info', 'bottom');
        console.error('Failed to load diff libraries:', error);
        return false;
      }
    },

    collectDiffPositions() {
      this.diffPositions = [];
      const scrollContainer = document.getElementById('diffScrollContainer');
      if (!scrollContainer) return;

      // Get all panels wrapper
      const panelsWrapper = scrollContainer.querySelector('.diff-panels-wrapper');
      if (!panelsWrapper) return;

      // We'll track diff groups by their vertical position
      const diffGroups = new Map();

      // Find all diff lines from both columns
      const allDiffLines = panelsWrapper.querySelectorAll('.diff-line.added, .diff-line.removed');

      // Group lines by their approximate vertical position
      allDiffLines.forEach(line => {
        const rect = line.getBoundingClientRect();
        const containerRect = scrollContainer.getBoundingClientRect();
        const relativeTop = rect.top - containerRect.top + scrollContainer.scrollTop;

        // Round to nearest 20px to group lines at similar heights
        const groupKey = Math.round(relativeTop / 20) * 20;

        if (!diffGroups.has(groupKey)) {
          diffGroups.set(groupKey, {
            position: relativeTop,
            lines: []
          });
        }

        diffGroups.get(groupKey).lines.push(line);
      });

      // Convert map to array and sort by position
      const sortedGroups = Array.from(diffGroups.values())
        .sort((a, b) => a.position - b.position);

      // Merge nearby groups and create final diff positions
      let currentGroup = null;

      sortedGroups.forEach(group => {
        if (!currentGroup || group.position - currentGroup.end > 50) {
          // Start a new group
          currentGroup = {
            start: group.position,
            end: group.position + 30, // Approximate height
            element: group.lines[0]
          };
          this.diffPositions.push(currentGroup);
        } else {
          // Extend the current group
          currentGroup.end = group.position + 30;
        }
      });

      this.currentDiffIndex = 0;
      this.updateDiffNav();
    },

    // Debug method to check if diff lines exist
    debugDiffLines() {
      const scrollContainer = document.getElementById('diffScrollContainer');
      if (!scrollContainer) {
        console.log('No scroll container found');
        return;
      }

      const diffLines = scrollContainer.querySelectorAll('.diff-line.added, .diff-line.removed');
      console.log(`Found ${diffLines.length} diff lines`);
      return diffLines.length;
    },

    updateDiffNav() {
      const navInfo = document.getElementById('diffNavInfo');
      const buttons = document.querySelectorAll('#diffNav button');
      const prevBtn = buttons[0];
      const nextBtn = buttons[1];

      if (this.diffPositions.length === 0) {
        navInfo.textContent = 'No differences';
        prevBtn.disabled = true;
        nextBtn.disabled = true;
      } else {
        navInfo.textContent = `${this.currentDiffIndex + 1} of ${this.diffPositions.length}`;
        prevBtn.disabled = this.currentDiffIndex === 0;
        nextBtn.disabled = this.currentDiffIndex === this.diffPositions.length - 1;
      }
    },

    scrollToDiff(index) {
      if (index < 0 || index >= this.diffPositions.length) return;

      const scrollContainer = document.getElementById('diffScrollContainer');
      if (!scrollContainer) return;

      const diff = this.diffPositions[index];
      const targetScroll = diff.start - 100; // 100px padding from top

      scrollContainer.scrollTo({
        top: targetScroll,
        behavior: 'smooth'
      });

      this.currentDiffIndex = index;
      this.updateDiffNav();
    },

    nextDiff() {
      if (this.currentDiffIndex < this.diffPositions.length - 1) {
        this.scrollToDiff(this.currentDiffIndex + 1);
      }
    },

    prevDiff() {
      if (this.currentDiffIndex > 0) {
        this.scrollToDiff(this.currentDiffIndex - 1);
      }
    },

    increaseFontSize() {
      if (this.currentFontSize < this.maxFontSize) {
        this.currentFontSize += 1;
        this.applyFontSize(true); // Show notification when user clicks button
      }
    },

    decreaseFontSize() {
      if (this.currentFontSize > this.minFontSize) {
        this.currentFontSize -= 1;
        this.applyFontSize(true); // Show notification when user clicks button
      }
    },

    applyFontSize(showNotification = false) {
      const codeElements = document.querySelectorAll('#diffOriginalCode, #diffModifiedCode');
      codeElements.forEach(element => {
        element.style.fontSize = this.currentFontSize + 'px';
      });

      // Also update line numbers if they exist
      const lineNumbers = document.querySelectorAll('.diff-line-number');
      lineNumbers.forEach(element => {
        element.style.fontSize = (this.currentFontSize - 1) + 'px';
      });

      // Only show feedback if explicitly requested (e.g., when user clicks +/- buttons)
      if (showNotification) {
        app.notify.show(document.getElementById('diffNav'), `Font size: ${this.currentFontSize}px`, 'info', 'bottom');
      }
    },

    updateDiffWithArchive(archiveHtml, filename = null) {
      // Show loading message
      app.fullscreenPopup.setContent('Diff Check', '<p>Updating diff comparison...</p>');

      try {
        // Get the current modified HTML
        const modifiedCode = app.clipboard.getMergedHtml();

        // Calculate diff with the archive as original
        const diff = window.Diff.diffLines(archiveHtml, modifiedCode);

        // Process diff to create aligned views
        const {
          originalLines,
          modifiedLines
        } = this.alignDiffLines(diff);

        // Build diff display
        let diffHtml = '<div class="diff-container">';
        diffHtml += '<div class="diff-scroll-container" id="diffScrollContainer">';
        diffHtml += '<div class="diff-panels-wrapper">';

        // Original column (now showing archive)
        diffHtml += '<div class="diff-column">';
        diffHtml += '<div class="diff-label">Archive (Original)</div>';
        diffHtml += '<pre class="language-javascript"><code id="diffOriginalCode">';
        originalLines.forEach((line, idx) => {
          if (line.empty) {
            diffHtml += `<span class="diff-line empty"><span class="diff-line-number">${idx + 1}</span></span>\n`;
          } else {
            const lineClass = line.removed ? 'removed' : '';
            const highlightedText = this.highlightCode(line.text);
            diffHtml += `<span class="diff-line ${lineClass}"><span class="diff-line-number">${idx + 1}</span>${highlightedText}</span>\n`;
          }
        });
        diffHtml += '</code></pre></div>';

        // Modified column
        diffHtml += '<div class="diff-column">';
        diffHtml += '<div class="diff-label">Modified</div>';
        diffHtml += '<pre class="language-javascript"><code id="diffModifiedCode">';
        modifiedLines.forEach((line, idx) => {
          if (line.empty) {
            diffHtml += `<span class="diff-line empty"><span class="diff-line-number">${idx + 1}</span></span>\n`;
          } else {
            const lineClass = line.added ? 'added' : '';
            const highlightedText = this.highlightCode(line.text);
            diffHtml += `<span class="diff-line ${lineClass}"><span class="diff-line-number">${idx + 1}</span>${highlightedText}</span>\n`;
          }
        });
        diffHtml += '</code></pre></div>';

        diffHtml += '</div></div></div>';

        // Update popup content
        app.fullscreenPopup.setContent('Diff Check', diffHtml);

        // Re-apply font size (without notification)
        this.applyFontSize(false);

        // Recollect diff positions after update
        requestAnimationFrame(() => {
          setTimeout(() => {
            const scrollContainer = document.getElementById('diffScrollContainer');
            if (scrollContainer) {
              void scrollContainer.offsetHeight;
              this.collectDiffPositions();
              if (this.diffPositions.length > 0) {
                this.scrollToDiff(0);
              }
            }
          }, 100);
        });

        // Clear the archive input and show notification
        const archiveInput = document.getElementById('archiveHtmlInput');
        if (archiveInput) {
          archiveInput.value = '';

          // Show notification with filename if provided, otherwise generic message
          const message = filename ? `Archive loaded: ${filename}` : 'Archive loaded!';

          // Show notification on diffNav which works reliably in the modal
          setTimeout(() => {
            const diffNav = document.getElementById('diffNav');
            if (diffNav) {
              app.notify.show(diffNav, message, 'info', 'bottom');
            }
          }, 100);
        }

      } catch (error) {
        app.fullscreenPopup.setContent('Error', '<p>Failed to update diff: ' + error.message + '</p>');
      }
    },

    setDiffContent(originalCode, modifiedCode) {
      // Set the content and highlight
      const origElement = document.getElementById('diffOriginal');
      const modElement = document.getElementById('diffModified');

      if (origElement) origElement.textContent = originalCode;
      if (modElement) modElement.textContent = modifiedCode;

      // Re-highlight with Prism
      if (window.Prism) {
        setTimeout(() => {
          Prism.highlightAll();
        }, 10);
      }
    },

    async testDiff() {
      const diffBtn = document.getElementById('diffCheckBtn');

      // First check if libraries need loading
      if (!this.isReady()) {
        const loaded = await this.loadLibraries(diffBtn);
        if (!loaded) return;
        return; // Exit after loading, require second click
      }

      // Libraries are loaded, check if we have original HTML
      if (!app.state.originalPastedHtml) {
        app.notify.show(diffBtn, 'No original HTML to compare', 'info', 'bottom');
        return;
      }

      // Get the original and current HTML
      const originalCode = app.state.originalPastedHtml;
      const modifiedCode = app.clipboard.getMergedHtml();

      // Use the generic showDiff function
      this.showDiff(originalCode, modifiedCode, 'Original', 'Modified', true);
    },

    // Generic diff comparison with custom button element
    async compareTexts(text1, text2, label1, label2, buttonElement) {
      // First check if libraries need loading
      if (!this.isReady()) {
        const loaded = await this.loadLibraries(buttonElement);
        if (!loaded) return false;
        return false; // Exit after loading, require second click
      }

      // Libraries are loaded, show the diff
      this.showDiff(text1, text2, label1, label2, false);
      return true;
    },

    escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    },

    alignDiffLines(diff) {
      const originalLines = [];
      const modifiedLines = [];

      diff.forEach(part => {
        const lines = part.value.split('\n').filter(line => line !== '');

        if (part.added) {
          // Added lines - show in modified, empty in original
          lines.forEach(line => {
            originalLines.push({
              text: '',
              empty: true
            });
            modifiedLines.push({
              text: line,
              added: true
            });
          });
        } else if (part.removed) {
          // Removed lines - show in original, empty in modified
          lines.forEach(line => {
            originalLines.push({
              text: line,
              removed: true
            });
            modifiedLines.push({
              text: '',
              empty: true
            });
          });
        } else {
          // Unchanged lines - show in both
          lines.forEach(line => {
            originalLines.push({
              text: line
            });
            modifiedLines.push({
              text: line
            });
          });
        }
      });

      return {
        originalLines,
        modifiedLines
      };
    },

    highlightCode(code) {
      // Determine the language based on file content
      let language = 'markup'; // default to HTML

      // Simple heuristic to detect language
      if (code.includes('<!DOCTYPE') || code.includes('<html')) {
        language = 'markup';
      } else if (code.includes('function') || code.includes('const ') || code.includes('var ')) {
        language = 'javascript';
      } else if (code.includes('{') && code.includes('}') && code.includes(':')) {
        language = 'css';
      }

      // Use Prism to highlight if available
      if (window.Prism && window.Prism.highlight && window.Prism.languages[language]) {
        return window.Prism.highlight(code, window.Prism.languages[language], language);
      }

      // Fallback to escaped text
      return this.escapeHtml(code);
    }
  },

  loadDiff: {
    loaded: false,

    load() {
      return new Promise((resolve, reject) => {
        if (this.loaded && window.Diff) {
          resolve();
          return;
        }

        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jsdiff/5.1.0/diff.min.js';
        script.onload = () => {
          this.loaded = true;
          console.log('jsdiff library loaded');
          resolve();
        };
        script.onerror = () => {
          console.error('Failed to load jsdiff');
          reject(new Error('Failed to load jsdiff'));
        };
        document.head.appendChild(script);
      });
    }
  },

  loadBeautify: {
    loaded: false,

    load() {
      return new Promise((resolve, reject) => {
        if (this.loaded && window.js_beautify) {
          resolve();
          return;
        }

        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/js-beautify/1.14.11/beautify.min.js';
        script.onload = () => {
          // Load HTML and CSS beautify modules
          const modules = [
            'https://cdnjs.cloudflare.com/ajax/libs/js-beautify/1.14.11/beautify-html.min.js',
            'https://cdnjs.cloudflare.com/ajax/libs/js-beautify/1.14.11/beautify-css.min.js'
          ];

          let loadedCount = 0;
          modules.forEach(url => {
            const moduleScript = document.createElement('script');
            moduleScript.src = url;
            moduleScript.onload = () => {
              loadedCount++;
              if (loadedCount === modules.length) {
                this.loaded = true;
                console.log('js-beautify library loaded');
                resolve();
              }
            };
            moduleScript.onerror = () => {
              console.error('Failed to load beautify module:', url);
              reject(new Error('Failed to load beautify modules'));
            };
            document.head.appendChild(moduleScript);
          });
        };
        script.onerror = () => {
          console.error('Failed to load js-beautify');
          reject(new Error('Failed to load js-beautify'));
        };
        document.head.appendChild(script);
      });
    }
  },

  beautify: {
    async run() {
      const beautifyBtn = document.getElementById('beautifyBtn');

      // Check if library is loaded
      if (!app.loadBeautify.loaded) {
        // First click - load library
        app.notify.show(beautifyBtn, 'Loading js-beautify...', 'info', 'bottom');

        try {
          await app.loadBeautify.load();
          app.notify.show(beautifyBtn, 'Loaded successfully!', 'info', 'bottom');
          console.log('Beautify library loaded successfully');
          return; // Exit without beautifying
        } catch (error) {
          app.notify.show(beautifyBtn, 'Failed to load library', 'info', 'bottom');
          console.error('Failed to load beautify library:', error);
          return;
        }
      }

      // Library is loaded, beautify the code
      try {
        // Beautify options
        const baseOptions = {
          indent_size: 2,
          indent_char: ' ',
          max_preserve_newlines: 2,
          preserve_newlines: true,
          end_with_newline: true,
          wrap_line_length: 0
        };

        const htmlOptions = {
          ...baseOptions,
          indent_inner_html: true,
          indent_scripts: 'keep', // Preserve script tag indentation
          wrap_attributes: 'auto', // Wrap attributes intelligently
          wrap_attributes_indent_size: 2,
          unformatted: ['code', 'pre', 'textarea'], // Don't format these tags
          content_unformatted: ['pre', 'code'], // Preserve content in these
          void_elements: ['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'link', 'meta', 'param', 'source', 'track', 'wbr']
        };

        const cssOptions = {
          ...baseOptions,
          selector_separator_newline: true, // New line after comma in selectors
          newline_between_rules: true, // Blank line between rules
          space_around_combinator: true // Space around > + ~ combinators
        };

        const jsOptions = {
          ...baseOptions,
          brace_style: 'collapse,preserve-inline', // Keep inline braces inline
          space_in_paren: false, // No space inside parentheses
          space_in_empty_paren: false,
          jslint_happy: false, // More modern formatting
          space_after_anon_function: true, // Space after anonymous function
          space_after_named_function: false, // No space after named function
          unindent_chained_methods: false, // Keep chained methods indented
          break_chained_methods: false, // Don't break method chains
          keep_array_indentation: false, // Reformat arrays
          unescape_strings: false, // Don't unescape strings
          e4x: true, // Support JSX-like syntax
          comma_first: false, // Commas at end of line
          operator_position: 'before-newline' // Operators at end of line
        };

        // Track changes
        let totalLinesChanged = 0;
        let filesChanged = 0;

        // Beautify HTML
        const htmlEditor = app.elements.editors.html;
        const originalHtml = htmlEditor.value;
        const beautifiedHtml = window.html_beautify(originalHtml, htmlOptions);
        if (originalHtml !== beautifiedHtml) {
          const originalLines = originalHtml.split('\n').length;
          const beautifiedLines = beautifiedHtml.split('\n').length;
          totalLinesChanged += Math.abs(beautifiedLines - originalLines);
          filesChanged++;
          htmlEditor.value = beautifiedHtml;
        }

        // Beautify CSS
        const cssEditor = app.elements.editors.css;
        const originalCss = cssEditor.value;
        const beautifiedCss = window.css_beautify(originalCss, cssOptions);
        if (originalCss !== beautifiedCss) {
          const originalLines = originalCss.split('\n').length;
          const beautifiedLines = beautifiedCss.split('\n').length;
          totalLinesChanged += Math.abs(beautifiedLines - originalLines);
          filesChanged++;
          cssEditor.value = beautifiedCss;
        }

        // Beautify JavaScript
        const jsEditor = app.elements.editors.js;
        const originalJs = jsEditor.value;
        const beautifiedJs = window.js_beautify(originalJs, jsOptions);
        if (originalJs !== beautifiedJs) {
          const originalLines = originalJs.split('\n').length;
          const beautifiedLines = beautifiedJs.split('\n').length;
          totalLinesChanged += Math.abs(beautifiedLines - originalLines);
          filesChanged++;
          jsEditor.value = beautifiedJs;
        }

        // Update preview if auto-run is enabled
        if (app.state.autoRun) {
          app.preview.update();
        }

        // Create informative message
        let message = 'Code beautified!';
        if (filesChanged === 0) {
          message = 'Already beautiful!';
        } else if (totalLinesChanged > 0) {
          message = `Beautified ${filesChanged} file${filesChanged > 1 ? 's' : ''}, ${totalLinesChanged > 0 ? '+' : ''}${totalLinesChanged} line${Math.abs(totalLinesChanged) !== 1 ? 's' : ''}`;
        } else {
          message = `Beautified ${filesChanged} file${filesChanged > 1 ? 's' : ''}`;
        }

        app.notify.show(beautifyBtn, message, 'info', 'bottom');
        console.log('Code beautified:', message);

      } catch (error) {
        app.notify.show(beautifyBtn, 'Beautify failed', 'info', 'bottom');
        console.error('Beautify error:', error);
      }
    }
  },

  state: {
    // Auto-save functionality
    autoSave: {
      isSupported: false,

      init() {
        // Check if localStorage is available
        try {
          if (typeof (Storage) !== 'undefined' && window.localStorage) {
            this.isSupported = true;
            // Don't auto-load on startup - user can load from Cache dialog if needed
            console.log('Auto-save enabled - content will persist across sessions');
          } else {
            console.log('localStorage not available - auto-save disabled');
          }
        } catch (e) {
          console.log('localStorage not supported in this environment');
          this.isSupported = false;
        }
      },

      saveToStorage() {
        if (!this.isSupported) return;

        try {
          const data = {
            html: app.elements.editors.html.value,
            css: app.elements.editors.css.value,
            js: app.elements.editors.js.value,
            timestamp: Date.now(),
            version: '1.0.0'
          };

          // Store as compressed JSON
          localStorage.setItem('catamaranCoder_editorContent', JSON.stringify(data));

          // Also store a backup of the last known good save
          localStorage.setItem('catamaranCoder_backup', JSON.stringify(data));

        } catch (e) {
          // Likely quota exceeded (5-10MB limit)
          console.warn('Failed to save to localStorage:', e);

          // Try to save just the most recent content
          try {
            localStorage.removeItem('catamaranCoder_backup');
            const minimalData = {
              html: app.elements.editors.html.value.substring(0, 100000),
              css: app.elements.editors.css.value.substring(0, 100000),
              js: app.elements.editors.js.value.substring(0, 100000),
              truncated: true
            };
            localStorage.setItem('catamaranCoder_editorContent', JSON.stringify(minimalData));
          } catch (e2) {
            console.error('Cannot save even truncated content');
          }
        }
      },

      loadFromStorage() {
        if (!this.isSupported) return;

        try {
          const saved = localStorage.getItem('catamaranCoder_editorContent');
          if (saved) {
            const data = JSON.parse(saved);

            // Check if data is recent (within last 7 days)
            const sevenDaysAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
            if (data.timestamp && data.timestamp > sevenDaysAgo) {
              // Restore content
              if (data.html) app.elements.editors.html.value = data.html;
              if (data.css) app.elements.editors.css.value = data.css;
              if (data.js) app.elements.editors.js.value = data.js;

              // Update preview
              if (app.state.autoRun) {
                app.preview.update();
              }

              // Notify user via Cache button
              console.log('Restored previous session', data.truncated ? '(truncated)' : '');

              // Show notification on Cache button
              setTimeout(() => {
                const cacheBtn = document.getElementById('storeAsBtn');
                if (cacheBtn) {
                  app.notify.show(cacheBtn, 'Session restored!', 'info', 'bottom');
                }
              }, 500);
            }
          }
        } catch (e) {
          console.error('Failed to load from localStorage:', e);
        }
      },

      clear() {
        if (!this.isSupported) return;

        try {
          localStorage.removeItem('catamaranCoder_editorContent');
          localStorage.removeItem('catamaranCoder_backup');
          console.log('Cleared saved content');
        } catch (e) {
          console.error('Failed to clear localStorage:', e);
        }
      }
    },

    // JS State Colors - Keep in sync with CSS :root variables
    // Default/Loaded/Viewed: Blue, Previewed: Red, Applied: Grey
    stateColors: {
      default: '#0066cc',
      loaded: '#0066cc',
      viewed: '#0066cc',
      previewed: '#cc0000',
      applied: '#666666'
    },

    pulseTextField(element) {
      if (!element) return;

      // Get current state and determine color
      const currentState = app.state.stepStates[app.state.currentStep] || 'Loaded';
      const stateKey = currentState.toLowerCase();
      const pulseColor = app.state.stateColors[stateKey] || app.state.stateColors.default;

      // Pulse with the appropriate color
      this.pulse(element, pulseColor);
    }

    ,

    activeTab: 'html',
    autoRun: true,
    showPreview: true,
    search: {
      text: '',
      matches: [],
      currentIndex: -1,
      threshold: 0
    },

    jsonData: null,
    currentStep: 0,
    currentOperationData: null,
    stepStates: [],
    originalPastedHtml: null
  },

  elements: {
    editors: {
      html: null,
      css: null,
      js: null
    },
    preview: null,
    autoRunCheckbox: null,
    findInput: null,
    findNumber: null,
    findButton: null
  },

  notify: {
    show(element, message, type = 'info', position = 'top') {
      // Check if element is a textarea or input (which don't support pseudo-elements)
      if (element.tagName === 'TEXTAREA' || element.tagName === 'INPUT') {
        this.showPositioned(element, message, position);
        return;
      }

      element.removeAttribute('data-notify');
      element.removeAttribute('data-notify-type');
      element.removeAttribute('data-notify-pos');

      void element.offsetWidth;

      element.setAttribute('data-notify', message);
      if (type !== 'info') element.setAttribute('data-notify-type', type);
      if (position !== 'top') element.setAttribute('data-notify-pos', position);

      setTimeout(() => {
        element.removeAttribute('data-notify');
        element.removeAttribute('data-notify-type');
        element.removeAttribute('data-notify-pos');
      }, 2000);
    },

    showPositioned(element, message, position = 'top') {
      const notify = document.getElementById('positionNotify');
      const rect = element.getBoundingClientRect();

      // Remove existing classes and animation
      notify.classList.remove('show', 'bottom');
      void notify.offsetWidth; // Force reflow

      // Set message
      notify.textContent = message;

      // Calculate position
      let x = rect.left + rect.width / 2;
      let y;

      if (position === 'bottom') {
        y = rect.bottom + 8;
        notify.classList.add('bottom');
      } else {
        y = rect.top - 8;
      }

      // Set position
      notify.style.left = x + 'px';
      notify.style.top = y + 'px';

      // Show notification
      notify.classList.add('show');

      // Hide after animation completes
      setTimeout(() => {
        notify.classList.remove('show');
      }, 2000);
    }
  },

  syntaxCheck: {
    acornLoaded: false,
    lastError: null,
    lastErrorTime: 0,

    loadAcorn() {
      return new Promise((resolve, reject) => {
        if (this.acornLoaded && window.acorn) {
          resolve();
          return;
        }

        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/acorn/8.11.3/acorn.min.js';
        script.onload = () => {
          this.acornLoaded = true;
          app.notify.show(document.getElementById('jsonWildcardBtn'), 'Acorn loaded!', 'info', 'bottom');
          resolve();
        };
        script.onerror = () => {
          app.notify.show(document.getElementById('jsonWildcardBtn'), 'Failed to load Acorn', 'info', 'bottom');
          reject(new Error('Failed to load Acorn'));
        };
        document.head.appendChild(script);
      });
    },

    async check() {
      const btn = document.getElementById('jsonWildcardBtn');

      // Check if user is pressing again within 5 seconds to copy last error
      const now = Date.now();
      if (this.lastError && (now - this.lastErrorTime) < 5000) {
        // Copy last error to clipboard
        const errorMessage = `Error on line ${this.lastError.loc.line}: ${this.lastError.message}`;
        navigator.clipboard.writeText(errorMessage).then(() => {
          app.notify.show(btn, 'Copied error to clipboard', 'info', 'bottom');
        }).catch(err => {
          app.notify.show(btn, 'Copy failed', 'info', 'bottom');
        });
        return;
      }

      // Load Acorn if not already loaded
      if (!this.acornLoaded) {
        app.notify.show(btn, 'Loading Acorn...', 'info', 'bottom');
        try {
          await this.loadAcorn();
        } catch (error) {
          return;
        }
      }

      // Get JavaScript code
      const jsCode = app.elements.editors.js.value;

      if (!jsCode.trim()) {
        app.notify.show(btn, 'No JavaScript to check', 'info', 'bottom');
        return;
      }

      // Check syntax
      try {
        window.acorn.parse(jsCode, {
          ecmaVersion: 'latest',
          sourceType: 'script',
          allowReturnOutsideFunction: true
        });

        app.notify.show(btn, 'No errors detected', 'info', 'bottom');
        console.log('✓ JavaScript syntax check passed - no errors found');

        // Clear last error since check passed
        this.lastError = null;
        this.lastErrorTime = 0;

      } catch (error) {
        // Store error for potential clipboard copy
        this.lastError = error;
        this.lastErrorTime = Date.now();
        // Log error details to console
        console.error('JavaScript Syntax Error:');
        console.error(`  Line ${error.loc.line}, Column ${error.loc.column}`);
        console.error(`  ${error.message}`);

        // Show brief error in tooltip
        app.notify.show(btn, `Error at line ${error.loc.line}`, 'info', 'bottom');

        // Switch to JS tab and highlight error location
        app.tabs.switch('js');

        // Calculate position of error
        const lines = jsCode.split('\n');
        let position = 0;
        for (let i = 0; i < error.loc.line - 1; i++) {
          position += lines[i].length + 1; // +1 for newline
        }
        position += error.loc.column;

        // Select error position
        const jsEditor = app.elements.editors.js;
        jsEditor.focus();
        jsEditor.setSelectionRange(position, position + 1);

        // Scroll to error position
        app.ui.scrollToPosition(jsEditor, position, 'center');

        // Show caret tooltip at error with detailed message
        const tooltipMessage = `Error on line ${error.loc.line}: ${error.message}`;
        app.caretTooltip.show(jsEditor, tooltipMessage, 4000);
      }
    }
  },

  ui: {
    initTextareaDoubleClick() {
      // List of all collapsible textareas
      const collapsibleTextareas = [
        'replaceInput',
        'jsonInput',
        'topLinesInput',
        'bottomLinesInput',
        'stepFind',
        'stepCode',
        'stepFiveLines',
        'findInput'
      ];

      // Add double-click listener to each textarea
      collapsibleTextareas.forEach(id => {
        const textarea = document.getElementById(id);
        if (textarea) {
          textarea.addEventListener('dblclick', (e) => {
            // Prevent default double-click behavior (select all)
            e.preventDefault();

            // Only collapse if the textarea is expanded
            const container = textarea.closest('.textarea-with-icons');
            if (container && container.classList.contains('expanded')) {
              this.collapseTextarea(id);
            }
          });
        }
      });
    },

    trackTextareaResize() {
      // Track which textareas have been resized
      const textareaDefaults = {
        'replaceInput': { width: 150, height: 32 },
        'jsonInput': { width: 150, height: 32 },
        'topLinesInput': { width: 120, height: 32 },
        'bottomLinesInput': { width: 120, height: 32 },
        'stepFind': { width: 200, height: 74 },
        'stepCode': { width: 200, height: 74 },
        'stepFiveLines': { width: 200, height: 74 },
        'findInput': { width: 180, height: 28 }
      };

      Object.keys(textareaDefaults).forEach(id => {
        const textarea = document.getElementById(id);
        if (!textarea) return;

        const defaults = textareaDefaults[id];
        const container = textarea.closest('.textarea-with-icons');
        if (!container) return;

        // Create ResizeObserver to watch for size changes
        const resizeObserver = new ResizeObserver(entries => {
          for (let entry of entries) {
            const width = entry.contentRect.width;
            const height = entry.contentRect.height;

            // Check if expanded beyond defaults (with 5px tolerance)
            const isExpanded = width > (defaults.width + 5) || height > (defaults.height + 5);

            if (isExpanded) {
              container.classList.add('expanded');
            } else {
              container.classList.remove('expanded');
            }
          }
        });

        resizeObserver.observe(textarea);
      });
    },

    scrollToPosition(textarea, targetPosition, placement = 'center') {
      // Save current selection
      const savedStart = textarea.selectionStart;
      const savedEnd = textarea.selectionEnd;

      // Temporarily move cursor to target position
      textarea.setSelectionRange(targetPosition, targetPosition);

      // Get the current scroll position before any changes
      const beforeScroll = textarea.scrollTop;

      // Force the browser to scroll the cursor into view
      textarea.blur();
      textarea.focus();

      // Let browser position it naturally first
      setTimeout(() => {
        const naturalScroll = textarea.scrollTop;
        const visibleHeight = textarea.clientHeight;

        // Now adjust based on placement preference
        let finalScroll = naturalScroll;

        switch (placement) {
          case 'top':
            // Already at top, maybe add small offset
            finalScroll = naturalScroll;
            break;
          case 'bottom':
            // Move up to show at bottom
            finalScroll = naturalScroll - visibleHeight + 100;
            break;
          case 'center':
          default:
            // Move up by half visible height
            finalScroll = naturalScroll - (visibleHeight / 3);
            break;
        }

        // Apply bounds
        const maxScroll = textarea.scrollHeight - visibleHeight;
        finalScroll = Math.max(0, Math.min(finalScroll, maxScroll));

        // Apply final scroll
        textarea.scrollTop = finalScroll;

        // Restore original selection
        textarea.setSelectionRange(savedStart, savedEnd);

        // If caret tooltip is active on this textarea, update its position
        if (app.caretTooltip.activeTextarea === textarea) {
          app.caretTooltip.updatePosition(textarea);
        }
      }, 0);
    },

    findCaret() {
      // Get the currently active editor
      const activeEditor = app.elements.editors[app.state.activeTab];

      // Focus the editor to ensure cursor is visible
      activeEditor.focus();

      // Show caret tooltip at current position
      app.caretTooltip.show(activeEditor, 'Looking for this?', 2500);

      // Also scroll to make sure cursor is visible
      const cursorPos = activeEditor.selectionStart;
      const text = activeEditor.value;
      const lines = text.substring(0, cursorPos).split('\n');
      const lineNumber = lines.length - 1;
      const lineHeight = parseInt(window.getComputedStyle(activeEditor).lineHeight);
      const scrollPosition = lineNumber * lineHeight;
      const viewportHeight = activeEditor.clientHeight;

      // Scroll to show cursor
      app.ui.scrollToPosition(activeEditor, cursorPos, 'center');
    },

    collapseTextarea(textareaId) {
      const textarea = document.getElementById(textareaId);
      const icon = null; // No more collapse icons
      const container = textarea.closest('.textarea-with-icons');

      // Get original dimensions based on textarea ID
      let originalWidth = '200px';
      let originalHeight = '74px';

      // Special cases for different textareas
      if (textareaId === 'replaceInput') {
        originalWidth = '150px';
        originalHeight = '32px';
      } else if (textareaId === 'findInput') {
        originalWidth = '180px';
        originalHeight = '28px';
      } else if (textareaId === 'jsonInput') {
        originalWidth = '150px';
        originalHeight = '32px';
      } else if (textareaId === 'topLinesInput' || textareaId === 'bottomLinesInput') {
        originalWidth = '120px';
        originalHeight = '32px';
      }

      // Collapse to original size
      textarea.style.width = originalWidth;
      textarea.style.height = originalHeight;

      // Remove expanded class since we're back to default
      if (container) {
        container.classList.remove('expanded');
      }

      // Show checkmark temporarily if icon exists
      if (icon) {
        const originalContent = icon.textContent;
        icon.textContent = '✓';

        setTimeout(() => {
          icon.textContent = originalContent;
        }, 1000);
      } else {
        // If no icon (called from double-click), show notification
        app.notify.show(textarea, 'Collapsed', 'info', 'bottom');
      }
    },

    transferSelection(sourceId, targetId, iconElement) {
      const source = document.getElementById(sourceId);
      const target = document.getElementById(targetId);

      if (!source || !target) return;

      // Get selected text from source
      const selectedText = source.value.substring(source.selectionStart, source.selectionEnd);

      if (!selectedText) {
        // No selection - show X temporarily
        const originalContent = iconElement.textContent;
        iconElement.textContent = '✗';

        setTimeout(() => {
          iconElement.textContent = originalContent;
        }, 1000);

        return;
      }

      // Transfer the selected text to target
      target.value = selectedText;

      // Show checkmark temporarily
      const originalContent = iconElement.textContent;
      iconElement.textContent = '✓';

      setTimeout(() => {
        iconElement.textContent = originalContent;
      }, 1000);

      // Optional: Focus the target field briefly to show the update
      target.focus();
      setTimeout(() => {
        source.focus();
      }, 100);
    },

    transferToTopBottom(sourceId, isTop, iconElement) {
      const source = document.getElementById(sourceId);
      const targetId = isTop ? 'topLinesInput' : 'bottomLinesInput';
      const targetInput = document.getElementById(targetId);
      const otherInputId = isTop ? 'bottomLinesInput' : 'topLinesInput';
      const otherInput = document.getElementById(otherInputId);

      if (!source || !targetInput) return;

      // Get selected text from source
      const selectedText = source.value.substring(source.selectionStart, source.selectionEnd);

      if (!selectedText) {
        // No selection - auto-fill with first and last 20 characters
        const fullText = source.value;
        if (!fullText) {
          // No text at all - show X
          const originalContent = iconElement.textContent;
          iconElement.textContent = '✗';
          setTimeout(() => {
            iconElement.textContent = originalContent;
          }, 1000);
          return;
        }

        // Fill both top and bottom fields
        const topInput = document.getElementById('topLinesInput');
        const bottomInput = document.getElementById('bottomLinesInput');

        // Number of characters to extract from start/end
        const charCount = 40;

        // Get first and last characters
        const firstChars = fullText.substring(0, Math.min(charCount, fullText.length));
        const lastChars = fullText.substring(Math.max(0, fullText.length - charCount));

        topInput.value = firstChars;
        bottomInput.value = lastChars;

        // Show checkmark
        const originalContent = iconElement.textContent;
        iconElement.textContent = '✓';
        setTimeout(() => {
          iconElement.textContent = originalContent;
        }, 1000);

        // Run the range selection
        app.selectRange(firstChars, lastChars);
        return;
      }

      // Transfer the selected text to target
      targetInput.value = selectedText;

      // Get the text from the other field
      const otherText = otherInput.value.trim();

      if (!otherText) {
        // Only one field filled - show checkmark but notify that both fields are needed
        const originalContent = iconElement.textContent;
        iconElement.textContent = '✓';

        setTimeout(() => {
          iconElement.textContent = originalContent;
        }, 1000);

        app.notify.show(iconElement, 'Fill other field too', 'info', 'bottom');
        return;
      }

      // Both fields have text - run selectRange
      const topText = document.getElementById('topLinesInput').value.trim();
      const bottomText = document.getElementById('bottomLinesInput').value.trim();

      // Show checkmark
      const originalContent = iconElement.textContent;
      iconElement.textContent = '✓';

      setTimeout(() => {
        iconElement.textContent = originalContent;
      }, 1000);

      // Run the range selection
      app.selectRange(topText, bottomText);
    },

    // Generic function to add vertical transfer arrows to any textarea
    addTransferArrows(textareaId) {
      const textarea = document.getElementById(textareaId);
      if (!textarea) return;

      const container = textarea.parentElement;
      const iconsDiv = container.querySelector('.textarea-icons');
      if (!iconsDiv) return;

      // Check if vertical arrows already exist
      if (iconsDiv.querySelector('.textarea-icons-vertical')) return;

      // Create vertical icons container
      const verticalDiv = document.createElement('div');
      verticalDiv.className = 'textarea-icons-vertical';

      // Create up arrow
      const upArrow = document.createElement('div');
      upArrow.className = 'textarea-icon';
      upArrow.textContent = '⤒';
      upArrow.title = 'Send to Top field & select range';
      upArrow.onclick = function () { app.ui.transferToTopBottom(textareaId, true, this); };

      // Create down arrow
      const downArrow = document.createElement('div');
      downArrow.className = 'textarea-icon';
      downArrow.textContent = '⤓';
      downArrow.title = 'Send to Bottom field & select range';
      downArrow.onclick = function () { app.ui.transferToTopBottom(textareaId, false, this); };

      verticalDiv.appendChild(upArrow);
      verticalDiv.appendChild(downArrow);
      iconsDiv.appendChild(verticalDiv);
    },

    // Compare stepFind and stepCode using diff check
    async compareStepFields(buttonElement) {
      const stepFind = document.getElementById('stepFind');
      const stepCode = document.getElementById('stepCode');

      if (!stepFind || !stepCode) {
        app.notify.show(buttonElement, 'Fields not found', 'info', 'bottom');
        return;
      }

      const findText = stepFind.value.trim();
      const codeText = stepCode.value.trim();

      if (!findText && !codeText) {
        app.notify.show(buttonElement, 'Both fields empty', 'info', 'bottom');
        return;
      }

      // Use the diffCheck compareTexts method
      app.diffCheck.compareTexts(
        findText || '(empty)',
        codeText || '(empty)',
        'Find Text',
        'Code Text',
        buttonElement
      );
    },

    pulse(element, color = '#ff6b6b', duration = 2000) {
      if (!element) return;

      // Remove any existing pulse class
      element.classList.remove('pulse-effect');

      // Set the pulse color as a CSS variable
      element.style.setProperty('--pulse-color', color);

      // Force reflow to restart animation
      void element.offsetWidth;

      // Add pulse class
      element.classList.add('pulse-effect');

      // Remove class and variable after animation completes
      setTimeout(() => {
        element.classList.remove('pulse-effect');
        element.style.removeProperty('--pulse-color');
      }, duration);
    },

    pulseTextField(element) {
      if (!element) return;

      // Get current state and determine color
      const currentState = app.state.stepStates[app.state.currentStep] || 'Loaded';
      const stateKey = currentState.toLowerCase();
      const pulseColor = app.state.stateColors[stateKey] || app.state.stateColors.default;

      // Pulse with the appropriate color
      this.pulse(element, pulseColor);
    }
  },

  rangeIndicators: {
    activeInterval: null,
    hideTimeout: null,

    calculatePosition(textarea, position, isEnd = false) {
      // Create a mirror div to calculate position
      const mirror = document.createElement('div');
      const computed = window.getComputedStyle(textarea);

      // Copy textarea styles to mirror
      mirror.style.position = 'absolute';
      mirror.style.visibility = 'hidden';
      mirror.style.whiteSpace = 'pre-wrap';
      mirror.style.wordWrap = 'break-word';
      mirror.style.overflow = 'hidden';

      // Copy relevant styles
      ['fontFamily', 'fontSize', 'fontWeight', 'fontStyle', 'letterSpacing',
        'textTransform', 'wordSpacing', 'textIndent', 'lineHeight',
        'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft',
        'borderTopWidth', 'borderRightWidth', 'borderBottomWidth', 'borderLeftWidth',
        'boxSizing', 'width', 'height'
      ].forEach(prop => {
        mirror.style[prop] = computed[prop];
      });

      document.body.appendChild(mirror);

      // Set content up to position
      const textBeforePosition = textarea.value.substring(0, position);
      mirror.textContent = textBeforePosition;

      // Add a span at the end to get position
      const span = document.createElement('span');
      span.textContent = '|';
      mirror.appendChild(span);

      const coords = {
        left: span.offsetLeft + parseInt(computed.paddingLeft),
        top: span.offsetTop + parseInt(computed.paddingTop) - textarea.scrollTop
      };

      document.body.removeChild(mirror);

      return coords;
    },

    updatePositions(textarea, startPos, endPos) {
      const topIndicator = document.getElementById('topIndicator');
      const bottomIndicator = document.getElementById('bottomIndicator');
      const topLine = document.getElementById('topRangeLine');
      const bottomLine = document.getElementById('bottomRangeLine');

      // Calculate positions
      const startCoords = this.calculatePosition(textarea, startPos);
      const endCoords = this.calculatePosition(textarea, endPos);

      const rect = textarea.getBoundingClientRect();
      const indicatorHeight = 35;

      // Position top indicator at start of selection
      let topX = rect.left + startCoords.left;
      let topY = rect.top + startCoords.top - indicatorHeight - 12;

      // Position bottom indicator at end of selection  
      let bottomX = rect.left + endCoords.left;
      let bottomY = rect.top + endCoords.top - indicatorHeight - 12;

      // Get editor container bounds for clamping
      const editorContainer = textarea.closest('.editor-container');
      const containerRect = editorContainer.getBoundingClientRect();

      // Get the editor tabs for top boundary
      const editorTabs = document.querySelector('.editor-tabs');
      const tabsRect = editorTabs.getBoundingClientRect();

      // Clamp positions
      const minY = tabsRect.bottom + 10;
      const maxY = containerRect.bottom - indicatorHeight - 10;
      const tooltipWidth = 120;
      const minX = containerRect.left + 10;
      const maxX = containerRect.right - tooltipWidth - 10;

      // Apply clamping to top indicator
      topY = Math.max(minY, Math.min(maxY, topY));
      topX = Math.max(minX, Math.min(maxX, topX));

      // Apply clamping to bottom indicator
      bottomY = Math.max(minY, Math.min(maxY, bottomY));
      bottomX = Math.max(minX, Math.min(maxX, bottomX));

      // If indicators would overlap, offset them horizontally
      if (Math.abs(bottomY - topY) < indicatorHeight && Math.abs(bottomX - topX) < tooltipWidth) {
        bottomX = Math.min(topX + tooltipWidth + 10, maxX);
      }

      // Set positions
      topIndicator.style.left = topX + 'px';
      topIndicator.style.top = topY + 'px';
      bottomIndicator.style.left = bottomX + 'px';
      bottomIndicator.style.top = bottomY + 'px';

      // Position the horizontal lines
      const lineStartY = rect.top + startCoords.top;
      const lineEndY = rect.top + endCoords.top;

      // Clamp line Y positions to editor bounds
      const clampedLineStartY = Math.max(containerRect.top, Math.min(containerRect.bottom, lineStartY));
      const clampedLineEndY = Math.max(containerRect.top, Math.min(containerRect.bottom, lineEndY));

      // Set line positions spanning full editor width
      topLine.style.left = containerRect.left + 'px';
      topLine.style.top = clampedLineStartY + 'px';
      topLine.style.width = containerRect.width + 'px';

      bottomLine.style.left = containerRect.left + 'px';
      bottomLine.style.top = clampedLineEndY + 'px';
      bottomLine.style.width = containerRect.width + 'px';

      // Determine arrow directions
      const startY = rect.top + startCoords.top;
      const endY = rect.top + endCoords.top;

      topIndicator.classList.remove('above', 'below');
      if (topY + indicatorHeight / 2 < startY) {
        topIndicator.classList.add('above');
      } else {
        topIndicator.classList.add('below');
      }

      bottomIndicator.classList.remove('above', 'below');
      if (bottomY + indicatorHeight / 2 < endY) {
        bottomIndicator.classList.add('above');
      } else {
        bottomIndicator.classList.add('below');
      }
    },

    show(textarea, startPos, endPos, duration = 18000) {
      const topIndicator = document.getElementById('topIndicator');
      const bottomIndicator = document.getElementById('bottomIndicator');

      // Clear any existing interval
      if (this.activeInterval) {
        clearInterval(this.activeInterval);
      }

      // Clear any existing hide timeout
      if (this.hideTimeout) {
        clearTimeout(this.hideTimeout);
        this.hideTimeout = null;
      }

      // Get current state color
      const currentState = app.state.stepStates[app.state.currentStep] || 'default';
      const stateKey = currentState.toLowerCase();
      const stateColor = app.state.stateColors[stateKey] || app.state.stateColors.default;

      // Apply state color to both indicators
      topIndicator.style.backgroundColor = stateColor;
      topIndicator.style.borderTopColor = stateColor;
      topIndicator.style.borderBottomColor = stateColor;
      bottomIndicator.style.backgroundColor = stateColor;
      bottomIndicator.style.borderTopColor = stateColor;
      bottomIndicator.style.borderBottomColor = stateColor;

      // Apply state color to lines
      const topLine = document.getElementById('topRangeLine');
      const bottomLine = document.getElementById('bottomRangeLine');
      topLine.style.borderTopColor = stateColor;
      bottomLine.style.borderTopColor = stateColor;

      // Set messages
      topIndicator.textContent = 'Top';
      bottomIndicator.textContent = 'Bottom';

      // Show indicators and lines
      topIndicator.classList.add('show');
      bottomIndicator.classList.add('show');
      topLine.classList.add('show');
      bottomLine.classList.add('show');

      // Wait for any scroll operations to complete
      setTimeout(() => {
        // Update positions after scroll has settled
        this.updatePositions(textarea, startPos, endPos);

        // Start continuous position updates
        this.activeInterval = setInterval(() => {
          this.updatePositions(textarea, startPos, endPos);
        }, 16); // ~60fps updates
      }, 50);

      // Hide after duration
      this.hideTimeout = setTimeout(() => {
        topIndicator.classList.remove('show');
        bottomIndicator.classList.remove('show');
        topLine.classList.remove('show');
        bottomLine.classList.remove('show');
        if (this.activeInterval) {
          clearInterval(this.activeInterval);
          this.activeInterval = null;
        }
        this.hideTimeout = null;
      }, duration);
    },

    hide() {
      const topIndicator = document.getElementById('topIndicator');
      const bottomIndicator = document.getElementById('bottomIndicator');
      const topLine = document.getElementById('topRangeLine');
      const bottomLine = document.getElementById('bottomRangeLine');

      topIndicator.classList.remove('show');
      bottomIndicator.classList.remove('show');
      topLine.classList.remove('show');
      bottomLine.classList.remove('show');

      if (this.activeInterval) {
        clearInterval(this.activeInterval);
        this.activeInterval = null;
      }

      if (this.hideTimeout) {
        clearTimeout(this.hideTimeout);
        this.hideTimeout = null;
      }
    }
  },

  caretTooltip: {
    activeInterval: null,
    activeTextarea: null,
    hideTimeout: null,

    updatePosition(textarea) {
      const tooltip = document.getElementById('caretTooltip');
      const position = textarea.selectionStart;

      // Create a mirror div to calculate position
      const mirror = document.createElement('div');
      const computed = window.getComputedStyle(textarea);

      // Copy textarea styles to mirror
      mirror.style.position = 'absolute';
      mirror.style.visibility = 'hidden';
      mirror.style.whiteSpace = 'pre-wrap';
      mirror.style.wordWrap = 'break-word';
      mirror.style.overflow = 'hidden';

      // Copy relevant styles
      ['fontFamily', 'fontSize', 'fontWeight', 'fontStyle', 'letterSpacing',
        'textTransform', 'wordSpacing', 'textIndent', 'lineHeight',
        'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft',
        'borderTopWidth', 'borderRightWidth', 'borderBottomWidth', 'borderLeftWidth',
        'boxSizing', 'width', 'height'
      ].forEach(prop => {
        mirror.style[prop] = computed[prop];
      });

      document.body.appendChild(mirror);

      // Set content up to caret position
      const textBeforeCaret = textarea.value.substring(0, position);
      mirror.textContent = textBeforeCaret;

      // Add a span at the end to get position
      const span = document.createElement('span');
      span.textContent = '|';
      mirror.appendChild(span);

      const coords = {
        left: span.offsetLeft + parseInt(computed.paddingLeft),
        top: span.offsetTop + parseInt(computed.paddingTop) - textarea.scrollTop
      };

      document.body.removeChild(mirror);

      // Position tooltip at caret location
      const rect = textarea.getBoundingClientRect();
      const tooltipHeight = 35; // Approximate height of tooltip

      // Calculate raw position
      let x = rect.left + coords.left;
      let y = rect.top + coords.top - tooltipHeight - 12; // Extra 12px clearance

      // Get editor container bounds for clamping
      const editorContainer = textarea.closest('.editor-container');
      const containerRect = editorContainer.getBoundingClientRect();

      // Get the editor tabs for top boundary
      const editorTabs = document.querySelector('.editor-tabs');
      const tabsRect = editorTabs.getBoundingClientRect();

      // Clamp Y position
      const minY = tabsRect.bottom + 10; // 10px below tabs
      const maxY = containerRect.bottom - tooltipHeight - 10; // 10px above bottom
      y = Math.max(minY, Math.min(maxY, y));

      // Clamp X position to stay within container
      const tooltipWidth = 120; // Approximate width
      const minX = containerRect.left + 10;
      const maxX = containerRect.right - tooltipWidth - 10;
      x = Math.max(minX, Math.min(maxX, x));

      tooltip.style.left = x + 'px';
      tooltip.style.top = y + 'px';

      // Determine if tooltip is above or below the caret
      const caretY = rect.top + coords.top;
      const tooltipMidpoint = y + tooltipHeight / 2;

      // Remove both classes first
      tooltip.classList.remove('above', 'below');

      // Add appropriate directional class
      if (tooltipMidpoint < caretY) {
        // Tooltip is above caret, triangle points down (default)
        tooltip.classList.add('above');
      } else {
        // Tooltip is below caret, triangle points up
        tooltip.classList.add('below');
      }
    },

    show(textarea, message, duration = 2000) {
      const tooltip = document.getElementById('caretTooltip');

      // Clear any existing interval
      if (this.activeInterval) {
        clearInterval(this.activeInterval);
      }

      // Clear any existing hide timeout
      if (this.hideTimeout) {
        clearTimeout(this.hideTimeout);
        this.hideTimeout = null;
      }

      // Store active textarea
      this.activeTextarea = textarea;

      // Set message and show tooltip
      tooltip.textContent = message;
      tooltip.classList.add('show');

      // Wait a tiny bit for any scroll operations to complete
      setTimeout(() => {
        // Update position after scroll has settled
        this.updatePosition(textarea);

        // Start continuous position updates
        this.activeInterval = setInterval(() => {
          if (this.activeTextarea) {
            this.updatePosition(this.activeTextarea);
          }
        }, 16); // ~60fps updates
      }, 50);

      // Hide after duration
      this.hideTimeout = setTimeout(() => {
        tooltip.classList.remove('show');
        if (this.activeInterval) {
          clearInterval(this.activeInterval);
          this.activeInterval = null;
        }
        this.activeTextarea = null;
        this.hideTimeout = null;
      }, duration);
    }
  },

  tabs: {
    switch (tab) {
      app.state.activeTab = tab;

      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tab')[['html', 'css', 'js'].indexOf(tab)].classList.add('active');

      document.querySelectorAll('.editor').forEach(e => e.classList.remove('active'));
      app.elements.editors[tab].classList.add('active');
    }
  },

  preview: {
    update() {
      const html = app.elements.editors.html.value;
      const css = app.elements.editors.css.value;
      const js = app.elements.editors.js.value;

      const previewContent = `
                        <!DOCTYPE html>
                        <html>
                        <head>
                            <meta charset="UTF-8">
                            <style>${css}</style>
                        </head>
                        <body>
                            ${html}
                            <script>${js}<\/script>
                        </body>
                        </html>
                    `;

      const blob = new Blob([previewContent], {
        type: 'text/html'
      });
      const url = URL.createObjectURL(blob);
      app.elements.preview.src = url;

      setTimeout(() => URL.revokeObjectURL(url), 1000);
    },

    runCode() {
      this.update();
      app.notify.show(document.getElementById('runBtn'), 'Code executed', 'info', 'bottom');
    }
  },

  clipboard: {

    downloadToPC() {
      // Get the entire Catamaran Coder application HTML
      const fullHTML = '<!DOCTYPE html>\n' + document.documentElement.outerHTML;

      // Extract version from footer or use default
      let version = '1.0';
      const footerText = document.querySelector('.footer-text');
      if (footerText) {
        const versionMatch = footerText.textContent.match(/v([\d.]+(?:-\w+)?)/i);
        if (versionMatch) {
          version = versionMatch[1];
        }
      }

      // Create filename
      const filename = `Catamaran Coder - V${version}.html`;

      // Create and download
      const blob = new Blob([fullHTML], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);

      setTimeout(() => URL.revokeObjectURL(url), 100);

      // No tooltip notification to avoid display issues
    },

    fileHandler: {

      readFile(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = (e) => resolve(e.target.result);
          reader.onerror = (e) => reject(e);
          reader.readAsText(file);
        });
      },

      async handleDroppedFile(file, targetElement, customHandler = null) {
        // Check if file is text-based
        const validTypes = ['text/html', 'text/plain', 'text/xml', 'application/xml'];
        const validExtensions = ['.html', '.htm', '.txt', '.xml', '.js', '.css', '.json'];

        const isValidType = validTypes.some(type => file.type.startsWith(type)) || file.type === '';
        const hasValidExtension = validExtensions.some(ext =>
          file.name.toLowerCase().endsWith(ext)
        );

        if (!isValidType && !hasValidExtension) {
          app.notify.show(targetElement, 'Please drop text-based files only', 'info', 'bottom');
          return;
        }

        try {
          // Show loading state
          app.notify.show(targetElement, 'Reading file...', 'info', 'bottom');

          // Read file content
          const content = await this.readFile(file);

          // If custom handler provided, use it
          if (customHandler) {
            customHandler(content, file.name, targetElement);
            return;
          }

          // Default behavior: set content to textarea
          targetElement.value = content;

          // Check if it's HTML and auto-load if so
          if (content.trim().length > 10 &&
            content.includes('<') && content.includes('>') &&
            (content.toLowerCase().includes('<!doctype') ||
              content.toLowerCase().includes('<html') ||
              content.toLowerCase().includes('<body'))) {
            // Auto-load the HTML
            app.clipboard.paste();
            app.notify.show(targetElement, `Loaded ${file.name}`, 'info', 'bottom');
          } else {
            app.notify.show(targetElement, `File loaded - ${file.name}`, 'info', 'bottom');
          }
        } catch (error) {
          app.notify.show(targetElement, 'Failed to read file', 'info', 'bottom');
          console.error('File read error:', error);
        }
      },

      initDragDrop(element, customHandler = null) {
        // First, prevent default document-level drag & drop to stop browser navigation
        let dragCounter = 0;

        // Document-level prevention (only set up once)
        if (!window._dragDropInitialized) {
          window._dragDropInitialized = true;

          // Prevent default behavior at document level
          document.addEventListener('dragover', (e) => {
            e.preventDefault();
            return false;
          });

          document.addEventListener('drop', (e) => {
            // Only prevent if not dropping on our textareas
            if (!e.target.closest('#replaceInput, #jsonInput, #archiveHtmlInput')) {
              e.preventDefault();
              return false;
            }
          });
        }

        // Element-specific handlers
        element.addEventListener('dragenter', (e) => {
          e.preventDefault();
          e.stopPropagation();
          dragCounter++;
          element.classList.add('drag-hover');
          return false;
        });

        element.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.stopPropagation();
          e.dataTransfer.dropEffect = 'copy';
          return false;
        });

        element.addEventListener('dragleave', (e) => {
          e.preventDefault();
          e.stopPropagation();
          dragCounter--;
          if (dragCounter === 0) {
            element.classList.remove('drag-hover');
          }
          return false;
        });

        element.addEventListener('drop', (e) => {
          e.preventDefault();
          e.stopPropagation();
          dragCounter = 0;
          element.classList.remove('drag-hover');

          const files = e.dataTransfer.files;
          if (files.length > 0) {
            // Handle only the first file, pass custom handler if provided
            this.handleDroppedFile(files[0], element, customHandler);
          }
          return false;
        });
      }
    },

    getMergedHtml() {
      let html = app.elements.editors.html.value;
      const css = app.elements.editors.css.value;
      const js = app.elements.editors.js.value;

      // Check if Update Version checkbox is checked and Session Name has V### pattern
      const updateVersionCheckbox = document.getElementById('updateVersionCheckbox');
      const sessionNameInput = document.getElementById('sessionNameInput');

      if (updateVersionCheckbox && updateVersionCheckbox.checked && sessionNameInput) {
        const sessionName = sessionNameInput.value;
        const versionMatch = sessionName.match(/^V(\d{3})(.*)/);

        if (versionMatch) {
          const versionNumber = versionMatch[1];
          const versionTitle = versionMatch[2]; // Everything after V###

          // Replace version tag with tag + version number (without V)
          // First, remove any existing version numbers after the tag
          html = html.replace(/(<!--\{\{### Version Here\}\}-->)\d*/g, '$1');
          // Then add the new version number
          html = html.replace(/<!--\{\{### Version Here\}\}-->/g, `<!--{{### Version Here}}-->${versionNumber}`);

          // Replace content between Version Title start/end markers
          const titleRegex = /(<!--\s*\{\{Version Title Start\}\}\s*-->)[\s\S]*?(<!--\s*\{\{Version Title End\}\}\s*-->)/g;
          html = html.replace(titleRegex, `$1${versionTitle}$2`);
        }
      }

      // Extract title from first h1 tag (text content only, ignoring nested tags)
      let title = 'Untitled';

      // Try to find h1 tag with proper handling of newlines and spaces
      const h1Match = html.match(/<h1[^>]*>([\s\S]*?)<\/h1>/i);

      if (h1Match && h1Match[1]) {
        // Strip HTML tags from the h1 content to get plain text
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = h1Match[1];
        const extractedTitle = (tempDiv.textContent || tempDiv.innerText || '').trim();

        // Use extracted title if it's not empty
        if (extractedTitle) {
          title = extractedTitle;
        }
      }

      // Fallback: if no h1 found, try h2, h3, or first text content
      if (title === 'Untitled') {
        // Try h2
        const h2Match = html.match(/<h2[^>]*>([\s\S]*?)<\/h2>/i);
        if (h2Match && h2Match[1]) {
          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = h2Match[1];
          const extractedTitle = (tempDiv.textContent || tempDiv.innerText || '').trim();
          if (extractedTitle) {
            title = extractedTitle;
          }
        }
      }

      console.log('Extracted title:', title); // Debug log

      const mergedContent = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>

    <!-- ========== CSS STYLES ========== -->
    <style>
${css}
    </style>
    <!-- ========== END CSS STYLES ========== -->
</head>
<body>
    <!-- ========== HTML CONTENT ========== -->
    ${html}
    <!-- ========== END HTML CONTENT ========== -->
    
    <!-- ========== JAVASCRIPT ========== -->
    <script>
${js}
    <\/script>
    <!-- ========== END JAVASCRIPT ========== -->
</body>
</html>`;

      return mergedContent;
    },

    copy() {
      const mergedContent = this.getMergedHtml();

      navigator.clipboard.writeText(mergedContent).then(() => {
        app.notify.show(document.getElementById('copyBtn'), 'Copied to clipboard', 'info', 'bottom');
      }).catch(err => {
        app.notify.show(document.getElementById('copyBtn'), 'Copy failed', 'info', 'bottom');
      });
    },

    openInNewWindow() {
      const mergedContent = this.getMergedHtml();

      // Open a blank window
      const newWindow = window.open('', '_blank');

      if (newWindow) {
        // Write the HTML directly to the new window's document
        newWindow.document.open();
        newWindow.document.write(mergedContent);
        newWindow.document.close();

        // Show success notification
        app.notify.show(document.getElementById('openBtn'), 'Opened in new window', 'info', 'bottom');
      } else {
        // Browser blocked the popup
        app.notify.show(document.getElementById('openBtn'), 'Popup blocked - please allow popups', 'info', 'bottom');
      }
    },

    copyAIPrompt() {
      const aiPrompt = `Please provide the code changes needed in the following JSON format:

{

  "changes": {

    "title": "Brief title of the change",

    "description": "Longer description of what the changes accomplish",

    "steps": [

      {

        "step": [step number],

        "operation-[add|replace|remove|replaceinstances]": {

          // For operation-add:

          "after-a-newline": "exact code to locate, followed by the new code on a new line",

          "code": "the new code to add",

          "find-in-section": "an HTML comment (e.g., <!-- Section Name -->) or ⦿ symbol (usually a header) or CSS /**/ or JS // comment,

          "five-lines-above": "up to 5 lines of code above the insertion point",

          "brief-explanation": "why this is being added"

          

          // For operation-replace:

          "find": "exact code to find and replace",

          "code": "the new code that replaces it",

          "find-in-section": "an HTML comment or tag near the change",

          "five-lines-above": "up to 5 lines of code above the code being replaced",

          "brief-explanation": "why this is being changed"

          

          // For operation-remove:

          "find": "exact code to remove",

          "find-in-section": "an HTML comment or tag near the change",

          "five-lines-above": "up to 5 lines of code above the code being removed",

          "brief-explanation": "why this is being removed"

          

          // For operation-replaceinstances:

          "find": "exact text to find and replace ALL instances of",

          "code": "the new text that replaces every instance",

          "find-in-section": "an HTML comment or tag (optional for this operation)",

          "five-lines-above": "up to 5 lines of code for context (optional)",

          "brief-explanation": "why all instances are being replaced"

        }

      }

    ]

  }

}

Rules:

1. OPERATIONS: Use "operation-add" to insert new code, "operation-replace" to modify existing code, "operation-remove" to delete code, and "operation-replaceinstances" to replace ALL occurrences of text across all files.

2. EXACT MATCHING: The "find" and "after-a-newline" fields must be EXACT matches, including whitespace. For "operation-add", include up to 5 lines of context ABOVE the insertion point in the "after-a-newline" JSON field to help locate the exact position.

3. ATOMIC STEPS: Each step should contain one logical change. Order steps so dependencies are satisfied (e.g., add before modifying the added code).

4. SECTION FINDING: Use "find-in-section" to specify location context. For HTML look for comments (<!-- Section -->) when available, usually with a ⦿ symbol for major sections. CSS and JS will usually have major sections with a ⦿ symbol inside, but normal /**/ and // comments can be used as well if a ⦿ can't be found.

5. REQUIRED FIELDS: All fields shown in the structure are required but may be empty strings if not applicable. If a target is not found, note this in "brief-explanation".

6. STRICT STRUCTURE: Follow the exact JSON structure provided with no additional fields.

7. REPLACE INSTANCES: Use "operation-replaceinstances" when you need to replace the same text multiple times across the codebase (e.g., renaming a variable, updating a repeated string, changing a class name used in multiple places).

Please analyze the code and provide the changes in this exact JSON structure.`;

      navigator.clipboard.writeText(aiPrompt).then(() => {
        app.notify.show(document.getElementById('aiPromptBtn'), 'AI prompt copied!', 'info', 'bottom');
      }).catch(err => {
        app.notify.show(document.getElementById('aiPromptBtn'), 'Copy failed', 'info', 'bottom');
      });
    },

    async paste() {
      try {
        const pasteInput = document.getElementById('replaceInput');
        const clipboardText = pasteInput.value;

        // Store the original HTML for diff checking later
        app.state.originalPastedHtml = clipboardText;

        if (!clipboardText.trim()) {
          app.notify.show(document.getElementById('replaceInput'), 'Nothing to paste', 'info', 'bottom');
          return;
        }

        const parser = new DOMParser();
        const doc = parser.parseFromString(clipboardText, 'text/html');

        const styles = doc.querySelectorAll('style');
        let cssContent = '';
        styles.forEach(style => {
          cssContent += style.textContent.trim() + '\n\n';
        });

        const scripts = doc.querySelectorAll('script');
        let jsContent = '';
        scripts.forEach(script => {
          jsContent += script.textContent.trim() + '\n\n';
        });

        const bodyCopy = doc.body.cloneNode(true);
        bodyCopy.querySelectorAll('style, script').forEach(el => el.remove());

        let htmlContent = bodyCopy.innerHTML.trim();

        const commentsToRemove = [
          '<!-- ========== CSS STYLES ========== -->',
          '<!-- ========== END CSS STYLES ========== -->',
          '<!-- ========== HTML CONTENT ========== -->',
          '<!-- ========== END HTML CONTENT ========== -->',
          '<!-- ========== JAVASCRIPT ========== -->',
          '<!-- ========== END JAVASCRIPT ========== -->'
        ];

        commentsToRemove.forEach(comment => {
          htmlContent = htmlContent.replace(comment, '');
        });

        htmlContent = htmlContent.trim();

        if (!cssContent && !jsContent && !htmlContent) {
          app.notify.show(document.getElementById('replaceInput'), 'No content detected', 'info', 'bottom');
          return;
        }

        if (htmlContent) app.elements.editors.html.value = htmlContent;
        if (cssContent) app.elements.editors.css.value = cssContent.trim();
        if (jsContent) app.elements.editors.js.value = jsContent.trim();

        if (app.state.autoRun) {
          app.preview.update();
        }

        // Pulse the paste input field green before clearing it
        app.ui.pulse(pasteInput, '#51cf66', 2000);

        pasteInput.value = '';
        app.notify.show(document.getElementById('replaceInput'), 'Content loaded', 'info', 'bottom');

      } catch (err) {
        app.notify.show(document.getElementById('replaceInput'), 'Parse error', 'info', 'bottom');
      }
    }
  },

  selectRange(topText, bottomText, notifyElement = null) {
    // Core logic for selecting a range between two text markers
    if (!topText || !bottomText) {
      // Clear any existing range indicators
      app.rangeIndicators.hide();
      if (notifyElement) {
        app.notify.show(notifyElement, 'Both texts required', 'info', 'bottom');
      }
      return false;
    }

    // Find the top text
    const topMatches = this.search.findAllMatches(topText, 1.0); // Exact match
    if (topMatches.length === 0) {
      // Clear any existing range indicators
      app.rangeIndicators.hide();
      if (notifyElement) {
        app.notify.show(notifyElement, 'Top text not found', 'info', 'bottom');
      }
      return false;
    }

    // Find the bottom text
    const bottomMatches = this.search.findAllMatches(bottomText, 1.0); // Exact match
    if (bottomMatches.length === 0) {
      // Clear any existing range indicators
      app.rangeIndicators.hide();
      if (notifyElement) {
        app.notify.show(notifyElement, 'Bottom text not found', 'info', 'bottom');
      }
      return false;
    }

    // Get the first match positions
    const firstMatch = topMatches[0];
    const startPos = firstMatch.index;

    // Find the bottom match that comes after the top match
    let endMatch = null;
    let maxEndPos = 0;

    for (const match of bottomMatches) {
      if (match.editor === firstMatch.editor) {
        const matchEnd = match.index + match.length;
        if (match.index >= startPos && matchEnd > maxEndPos) {
          endMatch = match;
          maxEndPos = matchEnd;
        }
      }
    }

    if (!endMatch) {
      // Clear any existing range indicators
      app.rangeIndicators.hide();
      if (notifyElement) {
        app.notify.show(notifyElement, 'Could not find valid range', 'info', 'bottom');
      }
      return false;
    }

    // Switch to the correct tab
    app.tabs.switch(firstMatch.editor);

    // Select the range from start to end
    const editor = firstMatch.element;
    editor.focus();
    editor.setSelectionRange(startPos, endMatch.index + endMatch.length);

    // Scroll to show the selection
    app.ui.scrollToPosition(editor, startPos, 'center');

    // Show range indicators at start and end positions
    app.rangeIndicators.show(editor, startPos, endMatch.index + endMatch.length, 18000);

    if (notifyElement) {
      app.notify.show(notifyElement, 'Range selected', 'info', 'bottom');
    }

    return true;
  },

  search: {
    // Normalize whitespace for comparison
    normalizeWhitespace(text) {
      return text.replace(/\s+/g, ' ').trim();
    },

    // Simple Levenshtein distance with early termination for efficiency
    levenshteinDistance(s1, s2, maxDistance = 5) {
      if (s1 === s2) return 0;
      if (s1.length === 0) return s2.length;
      if (s2.length === 0) return s1.length;

      // Early termination if length difference is too large
      if (Math.abs(s1.length - s2.length) > maxDistance) {
        return maxDistance + 1;
      }

      const matrix = [];
      for (let i = 0; i <= s2.length; i++) {
        matrix[i] = [i];
        if (i > maxDistance) matrix[i][0] = maxDistance + 1;
      }
      for (let j = 0; j <= s1.length; j++) {
        matrix[0][j] = j;
        if (j > maxDistance) matrix[0][j] = maxDistance + 1;
      }

      for (let i = 1; i <= s2.length; i++) {
        let rowMin = maxDistance + 1;
        for (let j = 1; j <= s1.length; j++) {
          if (s2.charAt(i - 1) === s1.charAt(j - 1)) {
            matrix[i][j] = matrix[i - 1][j - 1];
          } else {
            matrix[i][j] = Math.min(
              matrix[i - 1][j - 1] + 1, // substitution
              matrix[i][j - 1] + 1, // insertion
              matrix[i - 1][j] + 1 // deletion
            );
          }
          rowMin = Math.min(rowMin, matrix[i][j]);
        }
        // Early termination if this row has no values under maxDistance
        if (rowMin > maxDistance) {
          return maxDistance + 1;
        }
      }

      return matrix[s2.length][s1.length];
    },

    // Calculate match score based on search accuracy setting
    calculateMatchScore(searchText, targetText, accuracy) {
      if (accuracy >= 100) {
        // Exact match only
        return searchText === targetText ? 1.0 : 0.0;
      } else if (accuracy >= 90) {
        // Case-insensitive match
        return searchText.toLowerCase() === targetText.toLowerCase() ? 0.95 : 0.0;
      } else if (accuracy >= 80) {
        // Whitespace-normalized match
        const normalizedSearch = this.normalizeWhitespace(searchText.toLowerCase());
        const normalizedTarget = this.normalizeWhitespace(targetText.toLowerCase());
        return normalizedSearch === normalizedTarget ? 0.85 : 0.0;
      } else if (accuracy >= 60) {
        // Simple fuzzy with Levenshtein (max 3 edits)
        const distance = this.levenshteinDistance(
          searchText.toLowerCase(),
          targetText.toLowerCase(),
          3
        );
        if (distance <= 3) {
          return 1.0 - (distance * 0.2); // Score from 1.0 to 0.4
        }
        return 0.0;
      } else {
        // Very fuzzy with Levenshtein (max 5 edits)
        const distance = this.levenshteinDistance(
          searchText.toLowerCase(),
          targetText.toLowerCase(),
          5
        );
        if (distance <= 5) {
          return 1.0 - (distance * 0.15); // Score from 1.0 to 0.25
        }
        return 0.0;
      }
    },

    findAllMatches(searchText, matchThreshold) {
      const matches = [];
      const editors = [{
          name: 'html',
          element: app.elements.editors.html
        },
        {
          name: 'css',
          element: app.elements.editors.css
        },
        {
          name: 'js',
          element: app.elements.editors.js
        }
      ];

      const accuracy = parseInt(app.elements.findFuzzy.value) || 100;

      for (const editor of editors) {
        const text = editor.element.value;
        const searchLower = searchText.toLowerCase();
        const textLower = text.toLowerCase();

        if (accuracy >= 100) {
          // Exact match - case sensitive
          let index = 0;
          while (index < text.length) {
            const foundIndex = text.indexOf(searchText, index);
            if (foundIndex === -1) break;

            matches.push({
              editor: editor.name,
              element: editor.element,
              index: foundIndex,
              length: searchText.length,
              score: 1
            });

            index = foundIndex + 1;
          }
        } else if (accuracy >= 90) {
          // Case-insensitive match
          let index = 0;
          while (index < text.length) {
            const foundIndex = textLower.indexOf(searchLower, index);
            if (foundIndex === -1) break;

            matches.push({
              editor: editor.name,
              element: editor.element,
              index: foundIndex,
              length: searchText.length,
              score: 0.95
            });

            index = foundIndex + 1;
          }
        } else {
          // Fuzzy matching - sliding window approach
          // Only check reasonable window sizes to avoid performance issues
          const searchLen = searchText.length;
          const minLen = Math.max(1, searchLen - 3);
          const maxLen = Math.min(text.length, searchLen + 3);

          // Use larger step size for long texts to improve performance
          const stepSize = text.length > 1000 ? 2 : 1;

          for (let i = 0; i <= text.length - minLen; i += stepSize) {
            // Quick check: if first char doesn't match (case-insensitive), skip
            if (accuracy >= 80 && textLower[i] !== searchLower[0]) {
              continue;
            }

            for (let len = minLen; len <= maxLen && i + len <= text.length; len++) {
              const substring = text.substring(i, i + len);
              const score = this.calculateMatchScore(searchText, substring, accuracy);

              if (score > 0) {
                const overlaps = matches.some(m =>
                  m.editor === editor.name &&
                  !(i >= m.index + m.length || i + len <= m.index)
                );

                if (!overlaps) {
                  matches.push({
                    editor: editor.name,
                    element: editor.element,
                    index: i,
                    length: len,
                    score: score
                  });
                }
              }
            }
          }
        }
      }

      matches.sort((a, b) => {
        if (b.score !== a.score) return b.score - a.score;
        if (a.editor !== b.editor) {
          const order = {
            'html': 0,
            'css': 1,
            'js': 2
          };
          return order[a.editor] - order[b.editor];
        }
        return a.index - b.index;
      });

      return matches;
    },

    find() {
      const searchText = app.elements.findInput.value;
      if (!searchText) return;

      const matchThreshold = parseInt(app.elements.findFuzzy.value) / 100 || 1;
      const state = app.state.search;

      if (searchText !== state.text || matchThreshold !== state.threshold) {
        state.text = searchText;
        state.threshold = matchThreshold;
        state.matches = this.findAllMatches(searchText, matchThreshold);
        state.currentIndex = -1;
      }

      if (state.matches.length === 0) {
        app.notify.show(app.elements.findButton, 'No matches', 'info', 'bottom');
        return;
      }

      state.currentIndex = (state.currentIndex + 1) % state.matches.length;
      const match = state.matches[state.currentIndex];

      app.tabs.switch(match.editor);

      const textarea = match.element;
      textarea.focus();
      textarea.setSelectionRange(match.index, match.index + match.length);

      app.ui.scrollToPosition(textarea, match.index, 'center');

      // Show caret tooltip with match count
      app.caretTooltip.show(textarea, `Found ${state.currentIndex + 1}/${state.matches.length}`, 2000);

      const findButtonText = document.getElementById('findButtonText');
      if (findButtonText) {
        findButtonText.textContent = `${state.currentIndex + 1}/${state.matches.length}`;
      }
    },

    reset() {
      app.state.search.text = '';
      const findButtonText = document.getElementById('findButtonText');
      if (findButtonText) {
        findButtonText.textContent = '';
      }
    },

    useSelection() {
      // Get text from top/bottom fields
      const topText = document.getElementById('topLinesInput').value.trim();
      const bottomText = document.getElementById('bottomLinesInput').value.trim();

      // Call the reusable selectRange function
      app.selectRange(topText, bottomText, document.getElementById('useSelectionBtn'));
    },

    applyRange() {
      // Get text from top/bottom fields
      const topText = document.getElementById('topLinesInput').value.trim();
      const bottomText = document.getElementById('bottomLinesInput').value.trim();
      const applyBtn = document.getElementById('applyRangeBtn');

      // Step 1: Select the range (same as Use button)
      const rangeSelected = app.selectRange(topText, bottomText, null);

      if (!rangeSelected) {
        app.notify.show(applyBtn, 'Could not select range', 'info', 'bottom');
        return;
      }

      // Step 2: After delay, replace with stepCode content
      setTimeout(() => {
        const stepCode = document.getElementById('stepCode').value;

        if (!stepCode) {
          app.notify.show(applyBtn, 'No code to apply', 'info', 'bottom');
          return;
        }

        // Get active editor and current selection
        const activeEditor = app.elements.editors[app.state.activeTab];
        const selectionStart = activeEditor.selectionStart;
        const selectionEnd = activeEditor.selectionEnd;

        // Replace selected text with stepCode content
        const newValue = activeEditor.value.substring(0, selectionStart) +
          stepCode +
          activeEditor.value.substring(selectionEnd);
        activeEditor.value = newValue;

        // Step 3: Select the newly added text
        activeEditor.focus();
        activeEditor.setSelectionRange(selectionStart, selectionStart + stepCode.length);

        // Scroll to position
        app.ui.scrollToPosition(activeEditor, selectionStart, 'center');

        // Show caret tooltip at beginning of replaced area
        app.caretTooltip.show(activeEditor, "Replaced with Code:'s text!", 3000);

        // Show success notification on Apply button
        app.notify.show(applyBtn, 'Replaced successfully!', 'info', 'bottom');

        // Update preview if auto-run is enabled
        if (app.state.autoRun) {
          app.preview.update();
        }
      }, 50);
    }
  },

  jsonOps: {
    typeAnimation(textarea, text, cursorPos, callback) {
      let typedChars = 0;

      const typeNextChar = () => {
        if (typedChars < text.length) {
          // Insert next character
          const beforeText = textarea.value.substring(0, cursorPos + typedChars);
          const afterText = textarea.value.substring(cursorPos + typedChars);
          textarea.value = beforeText + text.charAt(typedChars) + afterText;

          typedChars++;
          textarea.setSelectionRange(cursorPos + typedChars, cursorPos + typedChars);

          setTimeout(typeNextChar, 5);
        } else {
          // Finished typing, now highlight the text
          textarea.focus();
          textarea.setSelectionRange(cursorPos, cursorPos + text.length);

          // After 500ms, remove the text and execute callback
          setTimeout(() => {
            // Remove the typed text
            const beforeText = textarea.value.substring(0, cursorPos);
            const afterText = textarea.value.substring(cursorPos + text.length);
            textarea.value = beforeText + afterText;

            // Reset cursor to original position
            textarea.setSelectionRange(cursorPos, cursorPos);

            if (callback) callback();
          }, 500);
        }
      };

      // Start typing animation
      typeNextChar();
    },

    findSection() {
      if (!app.state.currentOperationData) return;

      const sectionText = app.state.currentOperationData['find-in-section'] || '';
      if (!sectionText || sectionText === '-') {
        app.notify.show(document.querySelector('.step-info-table'), 'No section to find', 'info', 'bottom');
        return;
      }

      // Set the find input and trigger search
      app.elements.findInput.value = sectionText;
      app.elements.findFuzzy.value = '100'; // Set to exact match
      app.search.find();
    },

    findAllExactMatches(searchText) {
      const matches = [];
      const editors = [{
          name: 'html',
          element: app.elements.editors.html
        },
        {
          name: 'css',
          element: app.elements.editors.css
        },
        {
          name: 'js',
          element: app.elements.editors.js
        }
      ];

      for (const editor of editors) {
        const text = editor.element.value;
        let index = 0;

        while (index < text.length) {
          const foundIndex = text.indexOf(searchText, index);
          if (foundIndex === -1) break;

          matches.push({
            editor: editor.name,
            element: editor.element,
            index: foundIndex,
            length: searchText.length
          });

          index = foundIndex + 1;
        }
      }

      return matches;
    },

    animateMatches(matches, delay, callback, showTooltip = false, tooltipMessage = '') {
      let currentIndex = 0;

      const showNextMatch = () => {
        if (currentIndex >= matches.length) {
          if (callback) callback();
          return;
        }

        const match = matches[currentIndex];

        // Switch to the correct tab
        app.tabs.switch(match.editor);

        // Select the text
        const textarea = match.element;
        textarea.focus();
        textarea.setSelectionRange(match.index, match.index + match.length);

        // Scroll to the selection
        app.ui.scrollToPosition(textarea, match.index, 'center');

        // Show tooltip if requested
        if (showTooltip && tooltipMessage) {
          app.caretTooltip.show(textarea, tooltipMessage, delay + 50); // Show for slightly longer than delay
        }

        currentIndex++;

        if (currentIndex < matches.length) {
          setTimeout(showNextMatch, delay);
        } else if (callback) {
          setTimeout(callback, delay);
        }
      };

      showNextMatch();
    },

    loadJSON(jsonText, notifyElement = null, clearInput = true) {
      if (!jsonText) {
        if (notifyElement) {
          app.notify.show(notifyElement, 'No JSON to load', 'info', 'bottom');
        }
        return false;
      }

      try {
        const data = JSON.parse(jsonText);

        // Validate structure
        if (!data.changes || !data.changes.steps || !Array.isArray(data.changes.steps)) {
          throw new Error('Invalid JSON structure');
        }

        // Store in state
        app.state.jsonData = data;
        app.state.currentStep = 0;

        // Initialize step states
        app.state.stepStates = new Array(data.changes.steps.length).fill('Loaded');

        // Clear the input if requested
        if (clearInput) {
          const jsonInput = document.getElementById('jsonInput');
          jsonInput.value = '';
        }

        // Show success
        if (notifyElement) {
          app.notify.show(notifyElement,
            `Loaded ${data.changes.steps.length} steps`, 'info', 'bottom');
        }

        // Update step display if we have steps
        if (data.changes.steps.length > 0) {
          this.displayStep(0);
        }

        return true;

      } catch (err) {
        if (notifyElement) {
          app.notify.show(notifyElement, 'Invalid JSON', 'info', 'bottom');
        }
        return false;
      }
    },

    load() {
      const jsonInput = document.getElementById('jsonInput');
      const jsonText = jsonInput.value.trim();
      const loadBtn = document.getElementById('loadBtn');

      this.loadJSON(jsonText, loadBtn, true);
    },

    displayStep(index) {
      if (!app.state.jsonData || !app.state.jsonData.changes.steps[index]) return;

      const step = app.state.jsonData.changes.steps[index];
      app.state.currentStep = index;

      // Update step number with state indicator
      const totalSteps = app.state.jsonData.changes.steps.length;
      const currentState = app.state.stepStates[index] || 'Loaded';

      let stateIndicator = '';
      if (currentState === 'Viewed') {
        stateIndicator = ' — 🗸';
      } else if (currentState === 'Previewed') {
        stateIndicator = ' — 🗸🗸 (Previewed)';
      } else if (currentState === 'Applied') {
        stateIndicator = ' — ✓✓ (Applied)';
      }

      document.getElementById('stepNumber').textContent = `${step.step} of ${totalSteps}${stateIndicator}`;

      // Update table styling based on state
      const stepInfoTable = document.querySelector('.step-info-table');
      if (currentState === 'Applied') {
        stepInfoTable.classList.add('applied');
      } else {
        stepInfoTable.classList.remove('applied');
      }

      // Update editor selection colors based on state
      const editors = [app.elements.editors.html, app.elements.editors.css, app.elements.editors.js];
      editors.forEach(editor => {
        // Remove all state classes
        editor.classList.remove('state-previewed', 'state-applied');

        // Add appropriate state class
        if (currentState === 'Previewed') {
          editor.classList.add('state-previewed');
        } else if (currentState === 'Applied') {
          editor.classList.add('state-applied');
        }
        // Loaded and Viewed use default color, so no class needed
      });

      // Determine operation type and get operation data
      let operation = '';
      let explanation = '';
      let operationData = null;
      let findValue = '';
      let codeValue = '';
      let fiveLinesValue = '';

      if (step['operation-add']) {
        operation = 'add';
        operationData = step['operation-add'];
        explanation = operationData['brief-explanation'] || '';
        findValue = operationData['after-a-newline'] || '';
        codeValue = operationData['code'] || '';
        fiveLinesValue = operationData['five-lines-above'] || '';
      } else if (step['operation-replace']) {
        operation = 'replace';
        operationData = step['operation-replace'];
        explanation = operationData['brief-explanation'] || '';
        findValue = operationData['find'] || '';
        codeValue = operationData['code'] || '';
        fiveLinesValue = operationData['five-lines-above'] || '';
      } else if (step['operation-remove']) {
        operation = 'remove';
        operationData = step['operation-remove'];
        explanation = operationData['brief-explanation'] || '';
        findValue = operationData['find'] || '';
        codeValue = ''; // No code for remove operations
        fiveLinesValue = operationData['five-lines-above'] || '';
      } else if (step['operation-replaceinstances']) {
        operation = 'replaceinstances';
        operationData = step['operation-replaceinstances'];
        explanation = operationData['brief-explanation'] || '';
        findValue = operationData['find'] || '';
        codeValue = operationData['code'] || '';
        fiveLinesValue = operationData['five-lines-above'] || '';
      }

      // Update all fields
      document.getElementById('stepOperation').textContent = operation;
      document.getElementById('stepExplanation').textContent = explanation;

      // Update section field
      const sectionValue = operationData['find-in-section'] || '-';
      document.getElementById('stepSection').textContent = sectionValue;

      // Show/hide section row based on whether there's content
      const stepTable = document.querySelector('.step-info-table');
      if (stepTable) {
        if (sectionValue && sectionValue !== '-' && sectionValue.trim() !== '') {
          stepTable.classList.add('has-section');
        } else {
          stepTable.classList.remove('has-section');
        }
      }

      // Update step state to Viewed if it's still Loaded
      if (app.state.stepStates[index] === 'Loaded') {
        app.state.stepStates[index] = 'Viewed';
      }
      document.getElementById('stepFind').value = findValue;
      document.getElementById('stepCode').value = codeValue;
      document.getElementById('stepFiveLines').value = fiveLinesValue;

      // Store the full operation data for later use
      app.state.currentOperationData = operationData;
    },

    back() {
      if (!app.state.jsonData || !app.state.jsonData.changes.steps.length) {
        app.notify.show(document.getElementById('backBtn'), 'No data loaded', 'info', 'bottom');
        return;
      }

      const prevIndex = app.state.currentStep - 1;
      if (prevIndex < 0) {
        app.notify.show(document.getElementById('backBtn'), 'First step reached', 'info', 'bottom');
        return;
      }

      this.displayStep(prevIndex);
      app.notify.show(document.getElementById('backBtn'), `Step ${prevIndex + 1}`, 'info', 'bottom');
    },

    next() {
      if (!app.state.jsonData || !app.state.jsonData.changes.steps.length) {
        app.notify.show(document.getElementById('nextBtn'), 'No data loaded', 'info', 'bottom');
        return;
      }

      const nextIndex = app.state.currentStep + 1;
      if (nextIndex >= app.state.jsonData.changes.steps.length) {
        app.notify.show(document.getElementById('nextBtn'), 'Last step reached', 'info', 'bottom');
        return;
      }

      this.displayStep(nextIndex);
      app.notify.show(document.getElementById('nextBtn'), `Step ${nextIndex + 1}`, 'info', 'bottom');
    },

    getReady() {
      // Check if there's JSON to load first
      const jsonInput = document.getElementById('jsonInput');
      const jsonText = jsonInput.value.trim();

      if (jsonText) {
        // Try to load the JSON
        const loadSuccess = this.loadJSON(jsonText, document.getElementById('applyBtn'), true);
        if (!loadSuccess) {
          return; // Stop if JSON loading failed
        }
        // JSON loaded successfully, now proceed with Get Ready
      }

      if (!app.state.jsonData || !app.state.currentOperationData) {
        app.notify.show(document.getElementById('applyBtn'), 'No step loaded', 'info', 'bottom');
        return;
      }

      // Update step state to Previewed
      if (app.state.stepStates[app.state.currentStep] !== 'Applied') {
        app.state.stepStates[app.state.currentStep] = 'Previewed';
        // Update the step display
        this.displayStep(app.state.currentStep);
      }

      const currentStep = app.state.jsonData.changes.steps[app.state.currentStep];

      // Handle remove operation
      if (currentStep['operation-remove']) {
        const removeData = currentStep['operation-remove'];
        const textToFind = removeData['find'] || '';

        if (!textToFind) {
          app.notify.show(document.getElementById('applyBtn'), 'Nothing to remove', 'info', 'bottom');
          return;
        }

        // Use the fuzzy search to find the text
        const threshold = parseInt(app.elements.findFuzzy.value) / 100 || 1;
        const matches = app.search.findAllMatches(textToFind, threshold);

        if (matches.length > 0) {
          const match = matches[0];

          // Switch to the correct tab
          app.tabs.switch(match.editor);

          // Select the text
          const textarea = match.element;
          textarea.focus();
          textarea.setSelectionRange(match.index, match.index + match.length);

          // Scroll to show the selection properly
          app.ui.scrollToPosition(textarea, match.index, 'top');

          // Show caret tooltip for remove operation
          app.caretTooltip.show(textarea, 'Gets removed here', 3000);

          app.notify.show(document.getElementById('applyBtn'), 'Text selected', 'info', 'bottom');
        } else {
          // Pulse the find field to show where the problem is
          app.ui.pulseTextField(document.getElementById('stepFind'));
          app.notify.show(document.getElementById('applyBtn'), 'Text not found', 'info', 'bottom');
        }
      }

      // Handle replace operation
      else if (currentStep['operation-replace']) {
        const replaceData = currentStep['operation-replace'];
        const textToFind = replaceData['find'] || '';

        if (!textToFind) {
          app.notify.show(document.getElementById('applyBtn'), 'Nothing to replace', 'info', 'bottom');
          return;
        }

        // Use the fuzzy search to find the text
        const threshold = parseInt(app.elements.findFuzzy.value) / 100 || 1;
        const matches = app.search.findAllMatches(textToFind, threshold);

        if (matches.length > 0) {
          const match = matches[0];

          // Switch to the correct tab
          app.tabs.switch(match.editor);

          // Select the text
          const textarea = match.element;
          textarea.focus();
          textarea.setSelectionRange(match.index, match.index + match.length);

          // Scroll to the selection - position in upper third for better visibility
          const text = textarea.value;
          const lines = text.substring(0, match.index).split('\n');
          const lineNumber = lines.length - 1;
          const lineHeight = parseInt(window.getComputedStyle(textarea).lineHeight);
          const scrollPosition = lineNumber * lineHeight;
          app.ui.scrollToPosition(textarea, match.index, 'center');

          // Show caret tooltip for replace operation
          app.caretTooltip.show(textarea, 'This will be replaced:', 3000);

          app.notify.show(document.getElementById('applyBtn'), 'Text selected', 'info', 'bottom');
        } else {
          // Pulse the find field to show where the problem is
          app.ui.pulseTextField(document.getElementById('stepFind'));
          app.notify.show(document.getElementById('applyBtn'), 'Text not found', 'info', 'bottom');
        }
      }

      // Handle add operation
      else if (currentStep['operation-add']) {
        const addData = currentStep['operation-add'];
        const textToFind = addData['after-a-newline'] || '';

        if (!textToFind) {
          app.notify.show(document.getElementById('applyBtn'), 'No anchor text', 'info', 'bottom');
          return;
        }

        // Use the fuzzy search to find the text
        const threshold = parseInt(app.elements.findFuzzy.value) / 100 || 1;
        const matches = app.search.findAllMatches(textToFind, threshold);

        if (matches.length > 0) {
          const match = matches[0];

          // Switch to the correct tab
          app.tabs.switch(match.editor);

          // Position cursor after the found text
          const textarea = match.element;
          textarea.focus();
          const cursorPos = match.index + match.length;

          // Scroll to the position with extra space below cursor
          const text = textarea.value;
          const lines = text.substring(0, cursorPos).split('\n');
          const lineNumber = lines.length - 1;
          const lineHeight = parseInt(window.getComputedStyle(textarea).lineHeight);
          const scrollPosition = lineNumber * lineHeight;
          app.ui.scrollToPosition(textarea, match.index, 'center');

          // Show caret tooltip for add operation
          app.caretTooltip.show(textarea, 'Gets added here', 3000);

          // Use the typing animation system
          this.typeAnimation(textarea, '{{Gets added here}}', cursorPos, () => {
            app.notify.show(document.getElementById('applyBtn'), 'Position marked', 'info', 'bottom');
          });

        } else {
          // Pulse the find field to show where the problem is
          app.ui.pulseTextField(document.getElementById('stepFind'));
          app.notify.show(document.getElementById('applyBtn'), 'Anchor not found', 'info', 'bottom');
        }
      }

      // Handle replaceinstances operation
      else if (currentStep['operation-replaceinstances']) {
        const replaceData = currentStep['operation-replaceinstances'];
        const textToFind = replaceData['find'] || '';

        if (!textToFind) {
          app.notify.show(document.getElementById('applyBtn'), 'Nothing to find', 'info', 'bottom');
          return;
        }

        // Find all exact matches
        const matches = this.findAllExactMatches(textToFind);

        if (matches.length > 0) {
          app.notify.show(document.getElementById('applyBtn'),
            `Found ${matches.length} instance${matches.length > 1 ? 's' : ''}`, 'info', 'bottom');

          // Animate through all matches with 100ms delay, showing tooltip
          this.animateMatches(matches, 100, null, true, 'This will be replaced...');
        } else {
          // Pulse the find field to show where the problem is
          app.ui.pulseTextField(document.getElementById('stepFind'));
          app.notify.show(document.getElementById('applyBtn'), 'No matches found', 'info', 'bottom');
        }
      }

    },

    confirmAction() {
      if (!app.state.jsonData || !app.state.currentOperationData) {
        app.notify.show(document.getElementById('applyOperationBtn'), 'No step loaded', 'info', 'bottom');
        return;
      }
      // Function to update state to Applied after successful operation
      const updateToAppliedState = () => {
        app.state.stepStates[app.state.currentStep] = 'Applied';
        this.displayStep(app.state.currentStep);
      };

      // Store current selection before 5 lines check
      const activeEditor = app.elements.editors[app.state.activeTab];
      const selectionStart = activeEditor.selectionStart;
      const selectionEnd = activeEditor.selectionEnd;
      const hadFocus = document.activeElement === activeEditor;

      // Check if five-lines-above exists using the search functionality
      const override5Lines = document.getElementById('override5Lines').checked;
      if (!override5Lines) {
        const fiveLinesAbove = app.state.currentOperationData['five-lines-above'] || '';
        if (fiveLinesAbove) {
          // Use exact match (threshold 1.0) to find the five-lines-above text
          const matches = app.search.findAllMatches(fiveLinesAbove, 1.0);

          if (matches.length === 0) {
            app.notify.show(document.getElementById('applyOperationBtn'), '5 lines above not found - Re-selecting text', 'info', 'bottom');
            // Pulse the 5 lines field
            app.ui.pulseTextField(document.getElementById('stepFiveLines'));
            // Re-run Get Ready to re-select the text
            setTimeout(() => {
              this.getReady();
            }, 100);
            return;
          }
        }
      }

      const currentStep = app.state.jsonData.changes.steps[app.state.currentStep];

      // Handle remove operation
      if (currentStep['operation-remove']) {
        const removeData = currentStep['operation-remove'];
        const expectedText = removeData['find'] || '';

        // Get the currently active editor
        const activeEditor = app.elements.editors[app.state.activeTab];
        const selectionStart = activeEditor.selectionStart;
        const selectionEnd = activeEditor.selectionEnd;

        // Check if there's a selection
        if (selectionStart === selectionEnd) {
          app.notify.show(document.getElementById('applyOperationBtn'), 'No text selected', 'info', 'bottom');
          return;
        }

        // Get the selected text
        const selectedText = activeEditor.value.substring(selectionStart, selectionEnd);

        // Verify it matches what we expect to remove
        if (selectedText === expectedText) {
          // Remove the selected text
          const newValue = activeEditor.value.substring(0, selectionStart) +
            activeEditor.value.substring(selectionEnd);
          activeEditor.value = newValue;

          // Update cursor position
          activeEditor.setSelectionRange(selectionStart, selectionStart);

          // Show caret tooltip immediately for remove operation
          app.caretTooltip.show(activeEditor, 'Boom, gone!', 3000);

          // Type the Poof animation at the removal position
          this.typeAnimation(activeEditor, '{{Poof!}}', selectionStart, () => {
            // Update state to Applied since operation succeeded
            updateToAppliedState();

            // Update preview if auto-run is enabled
            if (app.state.autoRun) {
              app.preview.update();
            }

            app.notify.show(document.getElementById('applyOperationBtn'), 'Text removed', 'info', 'bottom');
          });
        } else {
          app.notify.show(document.getElementById('applyOperationBtn'), 'Selection mismatch', 'info', 'bottom');
        }
      }

      // Handle replace operation
      else if (currentStep['operation-replace']) {
        const replaceData = currentStep['operation-replace'];
        const expectedText = replaceData['find'] || '';
        const newCode = replaceData['code'] || '';

        // Get the currently active editor
        const activeEditor = app.elements.editors[app.state.activeTab];
        const selectionStart = activeEditor.selectionStart;
        const selectionEnd = activeEditor.selectionEnd;

        // Check if there's a selection
        if (selectionStart === selectionEnd) {
          app.notify.show(document.getElementById('applyOperationBtn'), 'No text selected', 'info', 'bottom');
          return;
        }

        // Get the selected text
        const selectedText = activeEditor.value.substring(selectionStart, selectionEnd);

        // Verify it matches what we expect to replace
        if (selectedText === expectedText) {
          // Replace the selected text with the new code
          const newValue = activeEditor.value.substring(0, selectionStart) +
            newCode +
            activeEditor.value.substring(selectionEnd);
          activeEditor.value = newValue;

          // Wait a moment for DOM update, then select the newly replaced text
          setTimeout(() => {
            activeEditor.focus();
            activeEditor.setSelectionRange(selectionStart, selectionStart + newCode.length);

            // Scroll to show the replaced text in the upper third of viewport
            const text = activeEditor.value;
            const lines = text.substring(0, selectionStart).split('\n');
            const lineNumber = lines.length - 1;
            const lineHeight = parseInt(window.getComputedStyle(activeEditor).lineHeight);
            const scrollPosition = lineNumber * lineHeight;
            app.ui.scrollToPosition(activeEditor, selectionStart, 'center');

            // Show caret tooltip for successful replacement
            app.caretTooltip.show(activeEditor, 'Voilà, replaced!', 3000);

            // Update state to Applied since operation succeeded
            updateToAppliedState();
          }, 10);

          // Update preview if auto-run is enabled
          if (app.state.autoRun) {
            app.preview.update();
          }

          app.notify.show(document.getElementById('applyOperationBtn'), 'Text replaced', 'info', 'bottom');
        } else {
          app.notify.show(document.getElementById('applyOperationBtn'), 'Selection mismatch', 'info', 'bottom');
        }
      }

      // Handle add operation
      else if (currentStep['operation-add']) {
        const addData = currentStep['operation-add'];
        const codeToAdd = addData['code'] || '';

        if (!codeToAdd) {
          app.notify.show(document.getElementById('applyOperationBtn'), 'No code to add', 'info', 'bottom');
          return;
        }

        // Get the currently active editor
        const activeEditor = app.elements.editors[app.state.activeTab];
        const cursorPos = activeEditor.selectionStart;

        // Insert the code at cursor position
        const newValue = activeEditor.value.substring(0, cursorPos) +
          '\n' + codeToAdd +
          activeEditor.value.substring(cursorPos);
        activeEditor.value = newValue;

        // Select the newly inserted code
        const selectionStart = cursorPos + 1; // +1 for the newline
        const selectionEnd = selectionStart + codeToAdd.length;
        activeEditor.focus();
        activeEditor.setSelectionRange(selectionStart, selectionEnd);

        // Delay scroll to ensure it happens after browser's auto-scroll
        setTimeout(() => {
          // Scroll to show the newly added text properly centered
          app.ui.scrollToPosition(activeEditor, selectionStart, 'center');

          // Show caret tooltip for successful addition
          app.caretTooltip.show(activeEditor, 'Presto, added!', 3000);
        }, 10);

        // Update state to Applied since operation succeeded
        updateToAppliedState();

        // Update preview if auto-run is enabled
        if (app.state.autoRun) {
          app.preview.update();
        }

        app.notify.show(document.getElementById('applyOperationBtn'), 'Code added', 'info', 'bottom');
      }

      // Handle replaceinstances operation
      else if (currentStep['operation-replaceinstances']) {
        const replaceData = currentStep['operation-replaceinstances'];
        const findText = replaceData['find'] || '';
        const replaceText = replaceData['code'] || '';

        if (!findText) {
          app.notify.show(document.getElementById('applyOperationBtn'), 'Nothing to find', 'info', 'bottom');
          return;
        }

        // Find all exact matches
        const matches = this.findAllExactMatches(findText);

        if (matches.length === 0) {
          app.notify.show(document.getElementById('applyOperationBtn'), 'No matches found', 'info', 'bottom');
          return;
        }

        let replacedCount = 0;
        let currentMatchIndex = 0;

        const replaceNextMatch = () => {
          if (currentMatchIndex >= matches.length) {
            // All done
            if (app.state.autoRun) {
              app.preview.update();
            }
            app.notify.show(document.getElementById('applyOperationBtn'),
              `Replaced ${replacedCount} instance${replacedCount > 1 ? 's' : ''}`, 'info', 'bottom');

            // Update state to Applied since all operations succeeded
            updateToAppliedState();
            return;
          }

          // We need to recalculate matches after each replacement because positions change
          const currentMatches = this.findAllExactMatches(findText);

          if (currentMatches.length > 0) {
            const match = currentMatches[0]; // Always take the first match

            // Switch to the correct tab
            app.tabs.switch(match.editor);

            // Select the text
            const textarea = match.element;
            textarea.focus();
            textarea.setSelectionRange(match.index, match.index + match.length);

            // Scroll to the selection
            const text = textarea.value;
            const lines = text.substring(0, match.index).split('\n');
            const lineNumber = lines.length - 1;
            const lineHeight = parseInt(window.getComputedStyle(textarea).lineHeight);
            const scrollPosition = lineNumber * lineHeight;
            app.ui.scrollToPosition(textarea, match.index, 'center');

            // Wait 100ms then replace
            setTimeout(() => {
              // Replace the selected text
              const newValue = textarea.value.substring(0, match.index) +
                replaceText +
                textarea.value.substring(match.index + match.length);
              textarea.value = newValue;

              // Keep the replaced text selected
              textarea.setSelectionRange(match.index, match.index + replaceText.length);

              // Show tooltip for successful replacement
              app.caretTooltip.show(textarea, 'Zing, replaced!', 150);

              replacedCount++;
              currentMatchIndex++;

              // Continue to next match after 100ms
              setTimeout(replaceNextMatch, 100);
            }, 100);
          } else {
            // No more matches
            if (app.state.autoRun) {
              app.preview.update();
            }
            app.notify.show(document.getElementById('applyOperationBtn'),
              `Replaced ${replacedCount} instance${replacedCount > 1 ? 's' : ''}`, 'info', 'bottom');

            // Update state to Applied since all operations succeeded
            updateToAppliedState();
          }
        };

        // Start the replacement animation
        replaceNextMatch();
      }
    }
  },

  events: {
    shortcuts: {
      'ctrl+alt+f': () => {
        app.elements.findInput.focus();
        app.search.find();
      },
      'ctrl+alt+k': () => {
        app.ui.findCaret();
      },
    },

    initShortcuts() {
      document.addEventListener('keydown', (e) => {
        const keys = [];
        if (e.ctrlKey) keys.push('ctrl');
        if (e.altKey) keys.push('alt');
        if (e.shiftKey) keys.push('shift');
        if (e.key && e.key.length === 1) {
          keys.push(e.key.toLowerCase());
        }

        const shortcut = keys.join('+');

        if (this.shortcuts[shortcut]) {
          e.preventDefault();
          this.shortcuts[shortcut]();
        }
      });

      // Auto-load HTML when pasted
      const replaceInput = document.getElementById('replaceInput');

      // Initialize drag & drop for HTML input
      app.clipboard.fileHandler.initDragDrop(replaceInput);

      // Also initialize for JSON input if you want drag & drop there too
      const jsonInput = document.getElementById('jsonInput');
      if (jsonInput) {
        app.clipboard.fileHandler.initDragDrop(jsonInput);
      }
      replaceInput.addEventListener('input', (e) => {
        const text = e.target.value.trim();

        // Simple check: contains HTML-like content
        if (text.length > 10 &&
          (text.includes('<') && text.includes('>')) &&
          (text.toLowerCase().includes('<!doctype') ||
            text.toLowerCase().includes('<html') ||
            text.toLowerCase().includes('<body') ||
            text.toLowerCase().includes('<div'))) {
          // Auto-load the HTML
          app.clipboard.paste();
          // Show success notification on the textarea
          app.notify.show(replaceInput, 'HTML loaded successfully!', 'info', 'bottom');
        }
      });
    },

    init() {
      this.initShortcuts();

      app.elements.autoRunCheckbox.addEventListener('change', (e) => {
        app.state.autoRun = e.target.checked;
      });

      // Show/hide preview toggle
      const showPreviewCheckbox = document.getElementById('showPreview');
      showPreviewCheckbox.addEventListener('change', (e) => {
        app.state.showPreview = e.target.checked;
        const previewSection = document.querySelector('.preview-section');
        const editorSection = document.querySelector('.editor-section');

        if (e.target.checked) {
          previewSection.classList.remove('hidden');
          editorSection.classList.remove('full-width');
        } else {
          previewSection.classList.add('hidden');
          editorSection.classList.add('full-width');
        }
      });

      const editors = [app.elements.editors.html, app.elements.editors.css, app.elements.editors.js];
      editors.forEach(editor => {
        editor.addEventListener('input', () => {
          if (app.state.autoRun) {
            app.preview.update();
          }
        });

        // Auto-save on input (debounced)
        let saveTimeout;
        editor.addEventListener('input', () => {
          clearTimeout(saveTimeout);
          saveTimeout = setTimeout(() => {
            app.state.autoSave.saveToStorage();
          }, 3000); // Save 3 seconds after user stops typing
        });

        editor.addEventListener('keydown', (e) => {
          if (e.key === 'Tab') {
            e.preventDefault();
            const start = editor.selectionStart;
            const end = editor.selectionEnd;
            editor.value = editor.value.substring(0, start) + '  ' + editor.value.substring(end);
            editor.selectionStart = editor.selectionEnd = start + 2;
          }
        });
      });

      app.elements.findInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          app.search.find();
        }
      });

      // Allow Enter key to search from the dropdown
      const fuzzyDropdown = document.getElementById('findFuzzy');
      if (fuzzyDropdown) {
        fuzzyDropdown.addEventListener('keypress', (e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            app.search.find();
          }
        });
      }

      app.elements.findInput.addEventListener('input', app.search.reset);
      app.elements.findFuzzy.addEventListener('change', app.search.reset);

      // Auto-load JSON when pasted
      const jsonInput = document.getElementById('jsonInput');
      jsonInput.addEventListener('input', (e) => {
        const text = e.target.value.trim();

        // Simple check: starts with { and ends with }
        if (text.length > 2 && text.charAt(0) === '{' && text.charAt(text.length - 1) === '}') {
          // Try to parse to verify it's valid JSON
          try {
            const data = JSON.parse(text);
            // Validate structure
            if (data.changes && data.changes.steps && Array.isArray(data.changes.steps)) {
              // If parse succeeds and structure is valid, auto-load
              if (app.jsonOps.loadJSON(text, null, true)) {
                app.notify.show(jsonInput, 'JSON loaded successfully!', 'info', 'bottom');
                // Pulse the JSON input field green
                app.ui.pulse(jsonInput, '#51cf66', 2000);
              }
            }
          } catch (err) {
            // Not valid JSON, do nothing
          }
        }
      });
    }
  },

  init() {
    this.elements.editors.html = document.getElementById('htmlEditor');
    this.elements.editors.css = document.getElementById('cssEditor');
    this.elements.editors.js = document.getElementById('jsEditor');
    this.elements.preview = document.getElementById('preview');
    this.elements.autoRunCheckbox = document.getElementById('autoRun');
    this.elements.findInput = document.getElementById('findInput');
    this.elements.findFuzzy = document.getElementById('findFuzzy');
    this.elements.findButton = document.querySelector('.search-button');

    this.events.init();
    this.preview.update();
    this.fullscreenPopup.init();
    this.state.autoSave.init();
    this.ui.trackTextareaResize();
    this.ui.initTextareaDoubleClick();
  }
};

// Show random flavor text on page load
(function () {
  const flavors = [
    "Very very Alpha",
    "Made in Paris!",
    "Save early, save often",
    "Made with Catamaran Coder™",
    "Works best with Claude AI",
    "Early Alpha preview",
    "Because why not?"
  ];
  const flavorElement = document.getElementById('flavorText');
  if (flavorElement) {
    flavorElement.textContent = flavors[Math.floor(Math.random() * flavors.length)];
    // Remove element after animation completes
    setTimeout(() => {
      flavorElement.remove();
    }, 2700);
  }
})();

app.init();
    </script>
    <!-- ========== END JAVASCRIPT ========== -->
</body>
</html>